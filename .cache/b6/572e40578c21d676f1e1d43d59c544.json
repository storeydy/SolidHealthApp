{"id":"node_modules/@inrupt/solid-client-authn-browser/dist/sessionInfo/SessionInfoManager.js","dependencies":[{"name":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\storeydy.github.io\\node_modules\\@inrupt\\solid-client-authn-browser\\dist\\sessionInfo\\SessionInfoManager.js.map","includedInParent":true,"mtime":1645788390864},{"name":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\storeydy.github.io\\node_modules\\@inrupt\\solid-client-authn-browser\\src\\sessionInfo\\SessionInfoManager.ts","includedInParent":true,"mtime":1645788390970},{"name":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\storeydy.github.io\\package.json","includedInParent":true,"mtime":1645788402217},{"name":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\storeydy.github.io\\node_modules\\@inrupt\\solid-client-authn-browser\\package.json","includedInParent":true,"mtime":1645788390926},{"name":"@inrupt/solid-client-authn-core","loc":{"line":4,"column":42},"parent":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\storeydy.github.io\\node_modules\\@inrupt\\solid-client-authn-browser\\dist\\sessionInfo\\SessionInfoManager.js","resolved":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\storeydy.github.io\\node_modules\\@inrupt\\solid-client-authn-core\\dist\\index.js"},{"name":"uuid","loc":{"line":5,"column":23},"parent":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\storeydy.github.io\\node_modules\\@inrupt\\solid-client-authn-browser\\dist\\sessionInfo\\SessionInfoManager.js","resolved":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\storeydy.github.io\\node_modules\\uuid\\dist\\esm-browser\\index.js"},{"name":"@inrupt/oidc-client-ext","loc":{"line":6,"column":34},"parent":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\storeydy.github.io\\node_modules\\@inrupt\\solid-client-authn-browser\\dist\\sessionInfo\\SessionInfoManager.js","resolved":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\storeydy.github.io\\node_modules\\@inrupt\\oidc-client-ext\\dist\\index.es.js"}],"generated":{"js":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SessionInfoManager = exports.clear = exports.getUnauthenticatedSession = void 0;\r\nconst solid_client_authn_core_1 = require(\"@inrupt/solid-client-authn-core\");\r\nconst uuid_1 = require(\"uuid\");\r\nconst oidc_client_ext_1 = require(\"@inrupt/oidc-client-ext\");\r\nfunction getUnauthenticatedSession() {\r\n    return {\r\n        isLoggedIn: false,\r\n        sessionId: uuid_1.v4(),\r\n        fetch,\r\n    };\r\n}\r\nexports.getUnauthenticatedSession = getUnauthenticatedSession;\r\nasync function clear(sessionId, storage) {\r\n    const storedSessionCookieReference = await storage.get(\"tmp-resource-server-session-info\");\r\n    const reference = JSON.parse(storedSessionCookieReference !== null && storedSessionCookieReference !== void 0 ? storedSessionCookieReference : \"{}\");\r\n    const { webId } = reference;\r\n    if (webId !== undefined) {\r\n        const webIdAsUrl = new URL(webId);\r\n        const resourceServerIri = webIdAsUrl.origin;\r\n        await storage.clearResourceServerSessionInfo(resourceServerIri);\r\n    }\r\n    await Promise.all([\r\n        storage.deleteAllUserData(sessionId, { secure: false }),\r\n        storage.deleteAllUserData(sessionId, { secure: true }),\r\n        storage.delete(\"clientKey\", { secure: false }),\r\n    ]);\r\n    await oidc_client_ext_1.clearOidcPersistentStorage();\r\n}\r\nexports.clear = clear;\r\nclass SessionInfoManager {\r\n    constructor(storageUtility) {\r\n        this.storageUtility = storageUtility;\r\n    }\r\n    update(_sessionId, _options) {\r\n        throw new Error(\"Not Implemented\");\r\n    }\r\n    async get(sessionId) {\r\n        var _a;\r\n        const isLoggedIn = await this.storageUtility.getForUser(sessionId, \"isLoggedIn\", {\r\n            secure: true,\r\n        });\r\n        const webId = await this.storageUtility.getForUser(sessionId, \"webId\", {\r\n            secure: true,\r\n        });\r\n        const clientId = await this.storageUtility.getForUser(sessionId, \"clientId\", {\r\n            secure: false,\r\n        });\r\n        const clientSecret = await this.storageUtility.getForUser(sessionId, \"clientSecret\", {\r\n            secure: false,\r\n        });\r\n        const idToken = await this.storageUtility.getForUser(sessionId, \"idToken\", {\r\n            secure: false,\r\n        });\r\n        const redirectUrl = await this.storageUtility.getForUser(sessionId, \"redirectUrl\", {\r\n            secure: false,\r\n        });\r\n        const refreshToken = await this.storageUtility.getForUser(sessionId, \"refreshToken\", {\r\n            secure: true,\r\n        });\r\n        const issuer = await this.storageUtility.getForUser(sessionId, \"issuer\", {\r\n            secure: false,\r\n        });\r\n        const tokenType = (_a = (await this.storageUtility.getForUser(sessionId, \"tokenType\", {\r\n            secure: false,\r\n        }))) !== null && _a !== void 0 ? _a : \"DPoP\";\r\n        if (!solid_client_authn_core_1.isSupportedTokenType(tokenType)) {\r\n            throw new Error(`Tokens of type [${tokenType}] are not supported.`);\r\n        }\r\n        if (clientId === undefined &&\r\n            idToken === undefined &&\r\n            isLoggedIn === undefined &&\r\n            webId === undefined &&\r\n            refreshToken === undefined) {\r\n            return undefined;\r\n        }\r\n        return {\r\n            sessionId,\r\n            webId,\r\n            isLoggedIn: isLoggedIn === \"true\",\r\n            redirectUrl,\r\n            idToken,\r\n            refreshToken,\r\n            issuer,\r\n            clientAppId: clientId,\r\n            clientAppSecret: clientSecret,\r\n            tokenType,\r\n        };\r\n    }\r\n    async getAll() {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n    async clear(sessionId) {\r\n        return clear(sessionId, this.storageUtility);\r\n    }\r\n    async register(_sessionId) {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n    async getRegisteredSessionIdAll() {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n    async clearAll() {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n}\r\nexports.SessionInfoManager = SessionInfoManager;\r\n"},"sourceMaps":{"js":{"version":3,"file":"SessionInfoManager.js","sourceRoot":"","sources":["../../src/sessionInfo/SessionInfoManager.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n * Copyright 2021 Inrupt Inc.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal in\r\n * the Software without restriction, including without limitation the rights to use,\r\n * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\r\n * Software, and to permit persons to whom the Software is furnished to do so,\r\n * subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\r\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\r\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\r\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\n/**\r\n * @hidden\r\n * @packageDocumentation\r\n */\r\n\r\nimport {\r\n  ISessionInfo,\r\n  ISessionInfoManager,\r\n  ISessionInternalInfo,\r\n  ISessionInfoManagerOptions,\r\n  IStorageUtility,\r\n  isSupportedTokenType,\r\n} from \"@inrupt/solid-client-authn-core\";\r\nimport { v4 } from \"uuid\";\r\nimport { clearOidcPersistentStorage } from \"@inrupt/oidc-client-ext\";\r\n\r\nexport function getUnauthenticatedSession(): ISessionInfo & {\r\n  fetch: typeof fetch;\r\n} {\r\n  return {\r\n    isLoggedIn: false,\r\n    sessionId: v4(),\r\n    fetch,\r\n  };\r\n}\r\n\r\n/**\r\n * @param sessionId\r\n * @param storage\r\n * @hidden\r\n */\r\nexport async function clear(\r\n  sessionId: string,\r\n  storage: IStorageUtility\r\n): Promise<void> {\r\n  const storedSessionCookieReference = await storage.get(\r\n    \"tmp-resource-server-session-info\"\r\n  );\r\n  const reference = JSON.parse(storedSessionCookieReference ?? \"{}\");\r\n  const { webId } = reference;\r\n  if (webId !== undefined) {\r\n    const webIdAsUrl = new URL(webId);\r\n    const resourceServerIri = webIdAsUrl.origin;\r\n    await storage.clearResourceServerSessionInfo(resourceServerIri);\r\n  }\r\n  await Promise.all([\r\n    storage.deleteAllUserData(sessionId, { secure: false }),\r\n    storage.deleteAllUserData(sessionId, { secure: true }),\r\n    // FIXME: This is needed until the DPoP key is stored safely\r\n    storage.delete(\"clientKey\", { secure: false }),\r\n  ]);\r\n  await clearOidcPersistentStorage();\r\n}\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport class SessionInfoManager implements ISessionInfoManager {\r\n  constructor(private storageUtility: IStorageUtility) {}\r\n\r\n  // eslint-disable-next-line class-methods-use-this\r\n  update(\r\n    _sessionId: string,\r\n    _options: ISessionInfoManagerOptions\r\n  ): Promise<void> {\r\n    // const localUserId: string = options.localUserId || this.uuidGenerator.v4();\r\n    // if (options.loggedIn) {\r\n    //   return {\r\n    //     sessionId,\r\n    //     loggedIn: true,\r\n    //     webId: options.webId as string,\r\n    //     neededAction: options.neededAction || { actionType: \"inaction\" },\r\n    //     state: options.state,\r\n    //     logout: async (): Promise<void> => {\r\n    //       // TODO: handle if webid isn't here\r\n    //       return this.logoutHandler.handle(localUserId);\r\n    //     },\r\n    //     fetch: (url: RequestInfo, init?: RequestInit): Promise<Response> => {\r\n    //       // TODO: handle if webid isn't here\r\n    //       return this.authenticatedFetcher.handle(\r\n    //         {\r\n    //           localUserId,\r\n    //           type: \"dpop\"\r\n    //         },\r\n    //         url,\r\n    //         init\r\n    //       );\r\n    //     }\r\n    //   };\r\n    // } else {\r\n    //   return {\r\n    //     localUserId,\r\n    //     loggedIn: false,\r\n    //     neededAction: options.neededAction || { actionType: \"inaction\" }\r\n    //   };\r\n    // }\r\n    throw new Error(\"Not Implemented\");\r\n  }\r\n\r\n  async get(\r\n    sessionId: string\r\n  ): Promise<(ISessionInfo & ISessionInternalInfo) | undefined> {\r\n    const isLoggedIn = await this.storageUtility.getForUser(\r\n      sessionId,\r\n      \"isLoggedIn\",\r\n      {\r\n        secure: true,\r\n      }\r\n    );\r\n\r\n    const webId = await this.storageUtility.getForUser(sessionId, \"webId\", {\r\n      secure: true,\r\n    });\r\n\r\n    const clientId = await this.storageUtility.getForUser(\r\n      sessionId,\r\n      \"clientId\",\r\n      {\r\n        secure: false,\r\n      }\r\n    );\r\n\r\n    const clientSecret = await this.storageUtility.getForUser(\r\n      sessionId,\r\n      \"clientSecret\",\r\n      {\r\n        secure: false,\r\n      }\r\n    );\r\n\r\n    const idToken = await this.storageUtility.getForUser(sessionId, \"idToken\", {\r\n      secure: false,\r\n    });\r\n\r\n    const redirectUrl = await this.storageUtility.getForUser(\r\n      sessionId,\r\n      \"redirectUrl\",\r\n      {\r\n        secure: false,\r\n      }\r\n    );\r\n\r\n    const refreshToken = await this.storageUtility.getForUser(\r\n      sessionId,\r\n      \"refreshToken\",\r\n      {\r\n        secure: true,\r\n      }\r\n    );\r\n\r\n    const issuer = await this.storageUtility.getForUser(sessionId, \"issuer\", {\r\n      secure: false,\r\n    });\r\n\r\n    const tokenType =\r\n      (await this.storageUtility.getForUser(sessionId, \"tokenType\", {\r\n        secure: false,\r\n      })) ?? \"DPoP\";\r\n\r\n    if (!isSupportedTokenType(tokenType)) {\r\n      throw new Error(`Tokens of type [${tokenType}] are not supported.`);\r\n    }\r\n\r\n    if (\r\n      clientId === undefined &&\r\n      idToken === undefined &&\r\n      isLoggedIn === undefined &&\r\n      webId === undefined &&\r\n      refreshToken === undefined\r\n    ) {\r\n      return undefined;\r\n    }\r\n\r\n    return {\r\n      sessionId,\r\n      webId,\r\n      isLoggedIn: isLoggedIn === \"true\",\r\n      redirectUrl,\r\n      idToken,\r\n      refreshToken,\r\n      issuer,\r\n      clientAppId: clientId,\r\n      clientAppSecret: clientSecret,\r\n      tokenType,\r\n    };\r\n  }\r\n\r\n  // eslint-disable-next-line class-methods-use-this\r\n  async getAll(): Promise<(ISessionInfo & ISessionInternalInfo)[]> {\r\n    throw new Error(\"Not implemented\");\r\n  }\r\n\r\n  /**\r\n   * This function removes all session-related information from storage.\r\n   * @param sessionId the session identifier\r\n   * @param storage the storage where session info is stored\r\n   * @hidden\r\n   */\r\n  async clear(sessionId: string): Promise<void> {\r\n    return clear(sessionId, this.storageUtility);\r\n  }\r\n\r\n  /**\r\n   * Registers a new session, so that its ID can be retrieved.\r\n   * @param sessionId\r\n   */\r\n  async register(_sessionId: string): Promise<void> {\r\n    throw new Error(\"Not implemented\");\r\n  }\r\n\r\n  /**\r\n   * Returns all the registered session IDs. Differs from getAll, which also\r\n   * returns additional session information.\r\n   */\r\n  async getRegisteredSessionIdAll(): Promise<string[]> {\r\n    throw new Error(\"Not implemented\");\r\n  }\r\n\r\n  /**\r\n   * Deletes all information about all sessions, including their registrations.\r\n   */\r\n  async clearAll(): Promise<void> {\r\n    throw new Error(\"Not implemented\");\r\n  }\r\n}\r\n"]}},"error":null,"hash":"f62e0adcfb67382338b1934de1dfda6f","cacheData":{"env":{}}}