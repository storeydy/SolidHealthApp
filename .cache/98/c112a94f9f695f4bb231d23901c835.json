{"id":"node_modules/@inrupt/solid-client-authn-core/dist/authenticatedFetch/fetchFactory.js","dependencies":[{"name":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\storeydy.github.io\\node_modules\\@inrupt\\solid-client-authn-core\\dist\\authenticatedFetch\\fetchFactory.js.map","includedInParent":true,"mtime":1645788390984},{"name":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\storeydy.github.io\\node_modules\\@inrupt\\solid-client-authn-core\\src\\authenticatedFetch\\fetchFactory.ts","includedInParent":true,"mtime":1645788391037},{"name":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\storeydy.github.io\\package.json","includedInParent":true,"mtime":1645788402217},{"name":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\storeydy.github.io\\node_modules\\@inrupt\\solid-client-authn-core\\package.json","includedInParent":true,"mtime":1645788391034},{"name":"../constant","loc":{"line":4,"column":27},"parent":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\storeydy.github.io\\node_modules\\@inrupt\\solid-client-authn-core\\dist\\authenticatedFetch\\fetchFactory.js","resolved":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\storeydy.github.io\\node_modules\\@inrupt\\solid-client-authn-core\\dist\\constant.js"},{"name":"./dpopUtils","loc":{"line":5,"column":28},"parent":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\storeydy.github.io\\node_modules\\@inrupt\\solid-client-authn-core\\dist\\authenticatedFetch\\fetchFactory.js","resolved":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\storeydy.github.io\\node_modules\\@inrupt\\solid-client-authn-core\\dist\\authenticatedFetch\\dpopUtils.js"},{"name":"../errors/OidcProviderError","loc":{"line":6,"column":36},"parent":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\storeydy.github.io\\node_modules\\@inrupt\\solid-client-authn-core\\dist\\authenticatedFetch\\fetchFactory.js","resolved":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\storeydy.github.io\\node_modules\\@inrupt\\solid-client-authn-core\\dist\\errors\\OidcProviderError.js"},{"name":"../errors/InvalidResponseError","loc":{"line":7,"column":39},"parent":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\storeydy.github.io\\node_modules\\@inrupt\\solid-client-authn-core\\dist\\authenticatedFetch\\fetchFactory.js","resolved":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\storeydy.github.io\\node_modules\\@inrupt\\solid-client-authn-core\\dist\\errors\\InvalidResponseError.js"}],"generated":{"js":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.buildAuthenticatedFetch = exports.DEFAULT_EXPIRATION_TIME_SECONDS = void 0;\r\nconst constant_1 = require(\"../constant\");\r\nconst dpopUtils_1 = require(\"./dpopUtils\");\r\nconst OidcProviderError_1 = require(\"../errors/OidcProviderError\");\r\nconst InvalidResponseError_1 = require(\"../errors/InvalidResponseError\");\r\nexports.DEFAULT_EXPIRATION_TIME_SECONDS = 600;\r\nfunction isExpectedAuthError(statusCode) {\r\n    return [401, 403].includes(statusCode);\r\n}\r\nasync function buildDpopFetchOptions(targetUrl, authToken, dpopKey, defaultOptions) {\r\n    var _a;\r\n    const options = { ...defaultOptions };\r\n    options.headers = {\r\n        ...defaultOptions === null || defaultOptions === void 0 ? void 0 : defaultOptions.headers,\r\n        Authorization: `DPoP ${authToken}`,\r\n        DPoP: await dpopUtils_1.createDpopHeader(targetUrl, (_a = defaultOptions === null || defaultOptions === void 0 ? void 0 : defaultOptions.method) !== null && _a !== void 0 ? _a : \"get\", dpopKey),\r\n    };\r\n    return options;\r\n}\r\nasync function buildAuthenticatedHeaders(targetUrl, authToken, dpopKey, defaultOptions) {\r\n    if (dpopKey !== undefined) {\r\n        return buildDpopFetchOptions(targetUrl, authToken, dpopKey, defaultOptions);\r\n    }\r\n    return {\r\n        ...defaultOptions,\r\n        headers: {\r\n            ...defaultOptions === null || defaultOptions === void 0 ? void 0 : defaultOptions.headers,\r\n            Authorization: `Bearer ${authToken}`,\r\n        },\r\n    };\r\n}\r\nasync function makeAuthenticatedRequest(unauthFetch, accessToken, url, defaultRequestInit, dpopKey) {\r\n    return unauthFetch(url, await buildAuthenticatedHeaders(url.toString(), accessToken, dpopKey, defaultRequestInit));\r\n}\r\nasync function refreshAccessToken(refreshOptions, dpopKey, eventEmitter) {\r\n    var _a;\r\n    const tokenSet = await refreshOptions.tokenRefresher.refresh(refreshOptions.sessionId, refreshOptions.refreshToken, dpopKey);\r\n    eventEmitter === null || eventEmitter === void 0 ? void 0 : eventEmitter.emit(constant_1.EVENTS.SESSION_EXTENDED, (_a = tokenSet.expiresIn) !== null && _a !== void 0 ? _a : exports.DEFAULT_EXPIRATION_TIME_SECONDS);\r\n    if (typeof tokenSet.refreshToken === \"string\") {\r\n        eventEmitter === null || eventEmitter === void 0 ? void 0 : eventEmitter.emit(constant_1.EVENTS.NEW_REFRESH_TOKEN, tokenSet.refreshToken);\r\n    }\r\n    return {\r\n        accessToken: tokenSet.accessToken,\r\n        refreshToken: tokenSet.refreshToken,\r\n        expiresIn: tokenSet.expiresIn,\r\n    };\r\n}\r\nconst computeRefreshDelay = (expiresIn) => {\r\n    if (expiresIn !== undefined) {\r\n        return expiresIn - constant_1.REFRESH_BEFORE_EXPIRATION_SECONDS > 0\r\n            ?\r\n                expiresIn - constant_1.REFRESH_BEFORE_EXPIRATION_SECONDS\r\n            : expiresIn;\r\n    }\r\n    return exports.DEFAULT_EXPIRATION_TIME_SECONDS;\r\n};\r\nasync function buildAuthenticatedFetch(unauthFetch, accessToken, options) {\r\n    var _a;\r\n    let currentAccessToken = accessToken;\r\n    let latestTimeout;\r\n    const currentRefreshOptions = options === null || options === void 0 ? void 0 : options.refreshOptions;\r\n    if (currentRefreshOptions !== undefined) {\r\n        const proactivelyRefreshToken = async () => {\r\n            var _a, _b, _c, _d;\r\n            try {\r\n                const { accessToken: refreshedAccessToken, refreshToken, expiresIn, } = await refreshAccessToken(currentRefreshOptions, options.dpopKey, options.eventEmitter);\r\n                currentAccessToken = refreshedAccessToken;\r\n                if (refreshToken !== undefined) {\r\n                    currentRefreshOptions.refreshToken = refreshToken;\r\n                }\r\n                clearTimeout(latestTimeout);\r\n                latestTimeout = setTimeout(proactivelyRefreshToken, computeRefreshDelay(expiresIn) * 1000);\r\n                (_a = options.eventEmitter) === null || _a === void 0 ? void 0 : _a.emit(constant_1.EVENTS.TIMEOUT_SET, latestTimeout);\r\n            }\r\n            catch (e) {\r\n                if (e instanceof OidcProviderError_1.OidcProviderError) {\r\n                    (_b = options === null || options === void 0 ? void 0 : options.eventEmitter) === null || _b === void 0 ? void 0 : _b.emit(constant_1.EVENTS.ERROR, e.error, e.errorDescription);\r\n                    (_c = options === null || options === void 0 ? void 0 : options.eventEmitter) === null || _c === void 0 ? void 0 : _c.emit(constant_1.EVENTS.SESSION_EXPIRED);\r\n                }\r\n                if (e instanceof InvalidResponseError_1.InvalidResponseError &&\r\n                    e.missingFields.includes(\"access_token\")) {\r\n                    (_d = options === null || options === void 0 ? void 0 : options.eventEmitter) === null || _d === void 0 ? void 0 : _d.emit(constant_1.EVENTS.SESSION_EXPIRED);\r\n                }\r\n            }\r\n        };\r\n        latestTimeout = setTimeout(proactivelyRefreshToken, computeRefreshDelay(options.expiresIn) * 1000);\r\n        (_a = options.eventEmitter) === null || _a === void 0 ? void 0 : _a.emit(constant_1.EVENTS.TIMEOUT_SET, latestTimeout);\r\n    }\r\n    else if (options !== undefined && options.eventEmitter !== undefined) {\r\n        const expirationTimeout = setTimeout(() => {\r\n            options.eventEmitter.emit(constant_1.EVENTS.SESSION_EXPIRED);\r\n        }, computeRefreshDelay(options.expiresIn) * 1000);\r\n        options.eventEmitter.emit(constant_1.EVENTS.TIMEOUT_SET, expirationTimeout);\r\n    }\r\n    return async (url, requestInit) => {\r\n        let response = await makeAuthenticatedRequest(unauthFetch, currentAccessToken, url, requestInit, options === null || options === void 0 ? void 0 : options.dpopKey);\r\n        const failedButNotExpectedAuthError = !response.ok && !isExpectedAuthError(response.status);\r\n        if (response.ok || failedButNotExpectedAuthError) {\r\n            return response;\r\n        }\r\n        const hasBeenRedirected = response.url !== url;\r\n        if (hasBeenRedirected && (options === null || options === void 0 ? void 0 : options.dpopKey) !== undefined) {\r\n            response = await makeAuthenticatedRequest(unauthFetch, currentAccessToken, response.url, requestInit, options.dpopKey);\r\n        }\r\n        return response;\r\n    };\r\n}\r\nexports.buildAuthenticatedFetch = buildAuthenticatedFetch;\r\n"},"sourceMaps":{"js":{"version":3,"file":"fetchFactory.js","sourceRoot":"","sources":["../../src/authenticatedFetch/fetchFactory.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n * Copyright 2021 Inrupt Inc.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal in\r\n * the Software without restriction, including without limitation the rights to use,\r\n * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\r\n * Software, and to permit persons to whom the Software is furnished to do so,\r\n * subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\r\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\r\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\r\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\n// eslint-disable-next-line no-shadow\r\nimport { fetch } from \"cross-fetch\";\r\nimport { EventEmitter } from \"events\";\r\nimport { REFRESH_BEFORE_EXPIRATION_SECONDS, EVENTS } from \"../constant\";\r\nimport { ITokenRefresher } from \"../login/oidc/refresh/ITokenRefresher\";\r\nimport { createDpopHeader, KeyPair } from \"./dpopUtils\";\r\nimport { OidcProviderError } from \"../errors/OidcProviderError\";\r\nimport { InvalidResponseError } from \"../errors/InvalidResponseError\";\r\n\r\nexport type RefreshOptions = {\r\n  sessionId: string;\r\n  refreshToken: string;\r\n  tokenRefresher: ITokenRefresher;\r\n};\r\n\r\n/**\r\n * If expires_in isn't specified for the access token, we assume its lifetime is\r\n * 10 minutes.\r\n */\r\nexport const DEFAULT_EXPIRATION_TIME_SECONDS = 600;\r\n\r\nfunction isExpectedAuthError(statusCode: number): boolean {\r\n  // As per https://tools.ietf.org/html/rfc7235#section-3.1 and https://tools.ietf.org/html/rfc7235#section-3.1,\r\n  // a response failing because the provided credentials aren't accepted by the\r\n  // server can get a 401 or a 403 response.\r\n  return [401, 403].includes(statusCode);\r\n}\r\n\r\nexport type DpopHeaderPayload = {\r\n  htu: string;\r\n  htm: string;\r\n  jti: string;\r\n};\r\n\r\nasync function buildDpopFetchOptions(\r\n  targetUrl: string,\r\n  authToken: string,\r\n  dpopKey: KeyPair,\r\n  defaultOptions?: RequestInit\r\n): Promise<RequestInit> {\r\n  const options: RequestInit = { ...defaultOptions };\r\n  options.headers = {\r\n    ...defaultOptions?.headers,\r\n    Authorization: `DPoP ${authToken}`,\r\n    DPoP: await createDpopHeader(\r\n      targetUrl,\r\n      defaultOptions?.method ?? \"get\",\r\n      dpopKey\r\n    ),\r\n  };\r\n  return options;\r\n}\r\n\r\nasync function buildAuthenticatedHeaders(\r\n  targetUrl: string,\r\n  authToken: string,\r\n  dpopKey?: KeyPair,\r\n  defaultOptions?: RequestInit\r\n): Promise<RequestInit> {\r\n  if (dpopKey !== undefined) {\r\n    return buildDpopFetchOptions(targetUrl, authToken, dpopKey, defaultOptions);\r\n  }\r\n  return {\r\n    ...defaultOptions,\r\n    headers: {\r\n      ...defaultOptions?.headers,\r\n      Authorization: `Bearer ${authToken}`,\r\n    },\r\n  };\r\n}\r\n\r\nasync function makeAuthenticatedRequest(\r\n  unauthFetch: typeof fetch,\r\n  accessToken: string,\r\n  url: RequestInfo,\r\n  defaultRequestInit?: RequestInit,\r\n  dpopKey?: KeyPair\r\n) {\r\n  return unauthFetch(\r\n    url,\r\n    await buildAuthenticatedHeaders(\r\n      url.toString(),\r\n      accessToken,\r\n      dpopKey,\r\n      defaultRequestInit\r\n    )\r\n  );\r\n}\r\n\r\nasync function refreshAccessToken(\r\n  refreshOptions: RefreshOptions,\r\n  dpopKey?: KeyPair,\r\n  eventEmitter?: EventEmitter\r\n): Promise<{ accessToken: string; refreshToken?: string; expiresIn?: number }> {\r\n  const tokenSet = await refreshOptions.tokenRefresher.refresh(\r\n    refreshOptions.sessionId,\r\n    refreshOptions.refreshToken,\r\n    dpopKey\r\n  );\r\n  eventEmitter?.emit(\r\n    EVENTS.SESSION_EXTENDED,\r\n    tokenSet.expiresIn ?? DEFAULT_EXPIRATION_TIME_SECONDS\r\n  );\r\n  if (typeof tokenSet.refreshToken === \"string\") {\r\n    eventEmitter?.emit(EVENTS.NEW_REFRESH_TOKEN, tokenSet.refreshToken);\r\n  }\r\n  return {\r\n    accessToken: tokenSet.accessToken,\r\n    refreshToken: tokenSet.refreshToken,\r\n    expiresIn: tokenSet.expiresIn,\r\n  };\r\n}\r\n\r\n/**\r\n *\r\n * @param expiresIn Delay until the access token expires.\r\n * @returns a delay until the access token should be refreshed.\r\n */\r\nconst computeRefreshDelay = (expiresIn?: number): number => {\r\n  if (expiresIn !== undefined) {\r\n    return expiresIn - REFRESH_BEFORE_EXPIRATION_SECONDS > 0\r\n      ? // We want to refresh the token 5 seconds before they actually expire.\r\n        expiresIn - REFRESH_BEFORE_EXPIRATION_SECONDS\r\n      : expiresIn;\r\n  }\r\n  return DEFAULT_EXPIRATION_TIME_SECONDS;\r\n};\r\n\r\n/**\r\n * @param unauthFetch a regular fetch function, compliant with the WHATWG spec.\r\n * @param authToken an access token, either a Bearer token or a DPoP one.\r\n * @param options The option object may contain two objects: the DPoP key token\r\n * is bound to if applicable, and options to customise token renewal behaviour.\r\n *\r\n * @returns A fetch function that adds an appropriate Authorization header with\r\n * the provided token, and adds a DPoP header if applicable.\r\n */\r\nexport async function buildAuthenticatedFetch(\r\n  unauthFetch: typeof fetch,\r\n  accessToken: string,\r\n  options?: {\r\n    dpopKey?: KeyPair;\r\n    refreshOptions?: RefreshOptions;\r\n    expiresIn?: number;\r\n    eventEmitter?: EventEmitter;\r\n  }\r\n): Promise<typeof fetch> {\r\n  let currentAccessToken = accessToken;\r\n  let latestTimeout: Parameters<typeof clearTimeout>[0];\r\n  const currentRefreshOptions: RefreshOptions | undefined =\r\n    options?.refreshOptions;\r\n  // Setup the refresh timeout outside of the authenticated fetch, so that\r\n  // an idle app will not get logged out if it doesn't issue a fetch before\r\n  // the first expiration date.\r\n  if (currentRefreshOptions !== undefined) {\r\n    const proactivelyRefreshToken = async () => {\r\n      try {\r\n        const {\r\n          accessToken: refreshedAccessToken,\r\n          refreshToken,\r\n          expiresIn,\r\n        } = await refreshAccessToken(\r\n          currentRefreshOptions,\r\n          // If currentRefreshOptions is defined, options is necessarily defined too.\r\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n          options!.dpopKey,\r\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n          options!.eventEmitter\r\n        );\r\n        // Update the tokens in the closure if appropriate.\r\n        currentAccessToken = refreshedAccessToken;\r\n        if (refreshToken !== undefined) {\r\n          currentRefreshOptions.refreshToken = refreshToken;\r\n        }\r\n        // Each time the access token is refreshed, we must plan fo the next\r\n        // refresh iteration.\r\n        clearTimeout(latestTimeout);\r\n        latestTimeout = setTimeout(\r\n          proactivelyRefreshToken,\r\n          computeRefreshDelay(expiresIn) * 1000\r\n        );\r\n        // If currentRefreshOptions is defined, options is necessarily defined too.\r\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n        options!.eventEmitter?.emit(EVENTS.TIMEOUT_SET, latestTimeout);\r\n      } catch (e) {\r\n        // It is possible that an underlying library throws an error on refresh flow failure.\r\n        // If we used a log framework, the error could be logged at the `debug` level,\r\n        // but otherwise the failure of the refresh flow should not blow up in the user's\r\n        // face, so we just swallow the error.\r\n        if (e instanceof OidcProviderError) {\r\n          // The OIDC provider refused to refresh the access token and returned an error instead.\r\n          /* istanbul ignore next 100% coverage would require testing that nothing\r\n              happens here if the emitter is undefined, which is more cumbersome\r\n              than what it's worth. */\r\n          options?.eventEmitter?.emit(\r\n            EVENTS.ERROR,\r\n            e.error,\r\n            e.errorDescription\r\n          );\r\n          /* istanbul ignore next 100% coverage would require testing that nothing\r\n            happens here if the emitter is undefined, which is more cumbersome\r\n            than what it's worth. */\r\n          options?.eventEmitter?.emit(EVENTS.SESSION_EXPIRED);\r\n        }\r\n        if (\r\n          e instanceof InvalidResponseError &&\r\n          e.missingFields.includes(\"access_token\")\r\n        ) {\r\n          // In this case, the OIDC provider returned a non-standard response, but\r\n          // did not specify that it was an error. We cannot refresh nonetheless.\r\n          /* istanbul ignore next 100% coverage would require testing that nothing\r\n            happens here if the emitter is undefined, which is more cumbersome\r\n            than what it's worth. */\r\n          options?.eventEmitter?.emit(EVENTS.SESSION_EXPIRED);\r\n        }\r\n      }\r\n    };\r\n    latestTimeout = setTimeout(\r\n      proactivelyRefreshToken,\r\n      // If currentRefreshOptions is defined, options is necessarily defined too.\r\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n      computeRefreshDelay(options!.expiresIn) * 1000\r\n    );\r\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n    options!.eventEmitter?.emit(EVENTS.TIMEOUT_SET, latestTimeout);\r\n  } else if (options !== undefined && options.eventEmitter !== undefined) {\r\n    // If no refresh options are provided, the session expires when the access token does.\r\n    const expirationTimeout = setTimeout(() => {\r\n      // The event emitter is always defined in our code, and it would be tedious\r\n      // to test for conditions when it is not.\r\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n      options.eventEmitter!.emit(EVENTS.SESSION_EXPIRED);\r\n    }, computeRefreshDelay(options.expiresIn) * 1000);\r\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n    options.eventEmitter!.emit(EVENTS.TIMEOUT_SET, expirationTimeout);\r\n  }\r\n  return async (url, requestInit?): Promise<Response> => {\r\n    let response = await makeAuthenticatedRequest(\r\n      unauthFetch,\r\n      currentAccessToken,\r\n      url,\r\n      requestInit,\r\n      options?.dpopKey\r\n    );\r\n\r\n    const failedButNotExpectedAuthError =\r\n      !response.ok && !isExpectedAuthError(response.status);\r\n    if (response.ok || failedButNotExpectedAuthError) {\r\n      // If there hasn't been a redirection, or if there has been a non-auth related\r\n      // issue, it should be handled at the application level\r\n      return response;\r\n    }\r\n    const hasBeenRedirected = response.url !== url;\r\n    if (hasBeenRedirected && options?.dpopKey !== undefined) {\r\n      // If the request failed for auth reasons, and has been redirected, we should\r\n      // replay it generating a DPoP header for the rediration target IRI. This\r\n      // doesn't apply to Bearer tokens, as the Bearer tokens aren't specific\r\n      // to a given resource and method, while the DPoP header (associated to a\r\n      // DPoP token) is.\r\n      response = await makeAuthenticatedRequest(\r\n        unauthFetch,\r\n        currentAccessToken,\r\n        // Replace the original target IRI (`url`) by the redirection target\r\n        response.url,\r\n        requestInit,\r\n        options.dpopKey\r\n      );\r\n    }\r\n    return response;\r\n  };\r\n}\r\n"]}},"error":null,"hash":"b5c650daba574cd57b54f7d5dd40f070","cacheData":{"env":{}}}