{"id":"node_modules/@inrupt/solid-client-authn-browser/dist/login/oidc/ClientRegistrar.js","dependencies":[{"name":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\storeydy.github.io\\node_modules\\@inrupt\\solid-client-authn-browser\\dist\\login\\oidc\\ClientRegistrar.js.map","includedInParent":true,"mtime":1645788390848},{"name":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\storeydy.github.io\\node_modules\\@inrupt\\solid-client-authn-browser\\src\\login\\oidc\\ClientRegistrar.ts","includedInParent":true,"mtime":1645788390954},{"name":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\storeydy.github.io\\package.json","includedInParent":true,"mtime":1645793376876},{"name":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\storeydy.github.io\\node_modules\\@inrupt\\solid-client-authn-browser\\package.json","includedInParent":true,"mtime":1645788390926},{"name":"@inrupt/oidc-client-ext","loc":{"line":3,"column":34},"parent":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\storeydy.github.io\\node_modules\\@inrupt\\solid-client-authn-browser\\dist\\login\\oidc\\ClientRegistrar.js","resolved":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\storeydy.github.io\\node_modules\\@inrupt\\oidc-client-ext\\dist\\index.es.js"}],"generated":{"js":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst oidc_client_ext_1 = require(\"@inrupt/oidc-client-ext\");\r\nclass ClientRegistrar {\r\n    constructor(storageUtility) {\r\n        this.storageUtility = storageUtility;\r\n    }\r\n    async getClient(options, issuerConfig) {\r\n        var _a;\r\n        const [storedClientId, storedClientSecret,] = await Promise.all([\r\n            this.storageUtility.getForUser(options.sessionId, \"clientId\", {\r\n                secure: false,\r\n            }),\r\n            this.storageUtility.getForUser(options.sessionId, \"clientSecret\", {\r\n                secure: false,\r\n            }),\r\n        ]);\r\n        if (storedClientId) {\r\n            return {\r\n                clientId: storedClientId,\r\n                clientSecret: storedClientSecret,\r\n                clientType: \"dynamic\",\r\n            };\r\n        }\r\n        const extendedOptions = { ...options };\r\n        extendedOptions.registrationAccessToken =\r\n            (_a = extendedOptions.registrationAccessToken) !== null && _a !== void 0 ? _a : (await this.storageUtility.getForUser(options.sessionId, \"registrationAccessToken\"));\r\n        try {\r\n            const registeredClient = await oidc_client_ext_1.registerClient(extendedOptions, issuerConfig);\r\n            const infoToSave = {\r\n                clientId: registeredClient.clientId,\r\n            };\r\n            if (registeredClient.clientSecret) {\r\n                infoToSave.clientSecret = registeredClient.clientSecret;\r\n            }\r\n            if (registeredClient.idTokenSignedResponseAlg) {\r\n                infoToSave.idTokenSignedResponseAlg =\r\n                    registeredClient.idTokenSignedResponseAlg;\r\n            }\r\n            await this.storageUtility.setForUser(extendedOptions.sessionId, infoToSave, {\r\n                secure: false,\r\n            });\r\n            return registeredClient;\r\n        }\r\n        catch (error) {\r\n            throw new Error(`Client registration failed: [${error.toString()}]`);\r\n        }\r\n    }\r\n}\r\nexports.default = ClientRegistrar;\r\n"},"sourceMaps":{"js":{"version":3,"file":"ClientRegistrar.js","sourceRoot":"","sources":["../../../src/login/oidc/ClientRegistrar.ts"],"names":[],"mappings":";;AAiCA,6DAAyD;AAKzD,MAAqB,eAAe;IAClC,YAAoB,cAA+B;QAA/B,mBAAc,GAAd,cAAc,CAAiB;IAAG,CAAC;IAEvD,KAAK,CAAC,SAAS,CACb,OAAgC,EAChC,YAA2B;;QAG3B,MAAM,CACJ,cAAc,EACd,kBAAkB,EAEnB,GAAG,MAAM,OAAO,CAAC,GAAG,CAAC;YACpB,IAAI,CAAC,cAAc,CAAC,UAAU,CAAC,OAAO,CAAC,SAAS,EAAE,UAAU,EAAE;gBAC5D,MAAM,EAAE,KAAK;aACd,CAAC;YACF,IAAI,CAAC,cAAc,CAAC,UAAU,CAAC,OAAO,CAAC,SAAS,EAAE,cAAc,EAAE;gBAChE,MAAM,EAAE,KAAK;aACd,CAAC;SAKH,CAAC,CAAC;QACH,IAAI,cAAc,EAAE;YAClB,OAAO;gBACL,QAAQ,EAAE,cAAc;gBACxB,YAAY,EAAE,kBAAkB;gBAChC,UAAU,EAAE,SAAS;aACtB,CAAC;SACH;QACD,MAAM,eAAe,GAAG,EAAE,GAAG,OAAO,EAAE,CAAC;QAEvC,eAAe,CAAC,uBAAuB;YACrC,MAAA,eAAe,CAAC,uBAAuB,mCACvC,CAAC,MAAM,IAAI,CAAC,cAAc,CAAC,UAAU,CACnC,OAAO,CAAC,SAAS,EACjB,yBAAyB,CAC1B,CAAC,CAAC;QAEL,IAAI;YACF,MAAM,gBAAgB,GAAG,MAAM,gCAAc,CAC3C,eAAe,EACf,YAAY,CACb,CAAC;YAEF,MAAM,UAAU,GAA2B;gBACzC,QAAQ,EAAE,gBAAgB,CAAC,QAAQ;aACpC,CAAC;YACF,IAAI,gBAAgB,CAAC,YAAY,EAAE;gBACjC,UAAU,CAAC,YAAY,GAAG,gBAAgB,CAAC,YAAY,CAAC;aACzD;YACD,IAAI,gBAAgB,CAAC,wBAAwB,EAAE;gBAC7C,UAAU,CAAC,wBAAwB;oBACjC,gBAAgB,CAAC,wBAAwB,CAAC;aAC7C;YACD,MAAM,IAAI,CAAC,cAAc,CAAC,UAAU,CAClC,eAAe,CAAC,SAAS,EACzB,UAAU,EACV;gBAIE,MAAM,EAAE,KAAK;aACd,CACF,CAAC;YACF,OAAO,gBAAgB,CAAC;SACzB;QAAC,OAAO,KAAK,EAAE;YACd,MAAM,IAAI,KAAK,CAAC,gCAAgC,KAAK,CAAC,QAAQ,EAAE,GAAG,CAAC,CAAC;SACtE;IACH,CAAC;CACF;AAvED,kCAuEC","sourcesContent":["/*\r\n * Copyright 2021 Inrupt Inc.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal in\r\n * the Software without restriction, including without limitation the rights to use,\r\n * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\r\n * Software, and to permit persons to whom the Software is furnished to do so,\r\n * subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\r\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\r\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\r\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\n/**\r\n * @hidden\r\n * @packageDocumentation\r\n */\r\n\r\nimport {\r\n  IStorageUtility,\r\n  IClientRegistrar,\r\n  IIssuerConfig,\r\n  IClient,\r\n  IClientRegistrarOptions,\r\n} from \"@inrupt/solid-client-authn-core\";\r\nimport { registerClient } from \"@inrupt/oidc-client-ext\";\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport default class ClientRegistrar implements IClientRegistrar {\r\n  constructor(private storageUtility: IStorageUtility) {}\r\n\r\n  async getClient(\r\n    options: IClientRegistrarOptions,\r\n    issuerConfig: IIssuerConfig\r\n  ): Promise<IClient> {\r\n    // If client secret and/or client id are stored in storage, use those.\r\n    const [\r\n      storedClientId,\r\n      storedClientSecret,\r\n      // storedClientName,\r\n    ] = await Promise.all([\r\n      this.storageUtility.getForUser(options.sessionId, \"clientId\", {\r\n        secure: false,\r\n      }),\r\n      this.storageUtility.getForUser(options.sessionId, \"clientSecret\", {\r\n        secure: false,\r\n      }),\r\n      // this.storageUtility.getForUser(options.sessionId, \"clientName\", {\r\n      //   // FIXME: figure out how to persist secure storage at reload\r\n      //   secure: false,\r\n      // }),\r\n    ]);\r\n    if (storedClientId) {\r\n      return {\r\n        clientId: storedClientId,\r\n        clientSecret: storedClientSecret,\r\n        clientType: \"dynamic\",\r\n      };\r\n    }\r\n    const extendedOptions = { ...options };\r\n    // If registration access token is stored, use that.\r\n    extendedOptions.registrationAccessToken =\r\n      extendedOptions.registrationAccessToken ??\r\n      (await this.storageUtility.getForUser(\r\n        options.sessionId,\r\n        \"registrationAccessToken\"\r\n      ));\r\n\r\n    try {\r\n      const registeredClient = await registerClient(\r\n        extendedOptions,\r\n        issuerConfig\r\n      );\r\n      // Save info\r\n      const infoToSave: Record<string, string> = {\r\n        clientId: registeredClient.clientId,\r\n      };\r\n      if (registeredClient.clientSecret) {\r\n        infoToSave.clientSecret = registeredClient.clientSecret;\r\n      }\r\n      if (registeredClient.idTokenSignedResponseAlg) {\r\n        infoToSave.idTokenSignedResponseAlg =\r\n          registeredClient.idTokenSignedResponseAlg;\r\n      }\r\n      await this.storageUtility.setForUser(\r\n        extendedOptions.sessionId,\r\n        infoToSave,\r\n        {\r\n          // FIXME: figure out how to persist secure storage at reload\r\n          // Otherwise, the client info cannot be retrieved from storage, and\r\n          // the lib tries to re-register the client on each fetch\r\n          secure: false,\r\n        }\r\n      );\r\n      return registeredClient;\r\n    } catch (error) {\r\n      throw new Error(`Client registration failed: [${error.toString()}]`);\r\n    }\r\n  }\r\n}\r\n"]}},"error":null,"hash":"72ae515da7753ae3b0eb3304a56463d9","cacheData":{"env":{}}}