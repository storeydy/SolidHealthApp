{"id":"node_modules/@inrupt/solid-client-authn-core/dist/storage/StorageUtility.js","dependencies":[{"name":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\storeydy.github.io\\node_modules\\@inrupt\\solid-client-authn-core\\dist\\storage\\StorageUtility.js.map","includedInParent":true,"mtime":1645788391026},{"name":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\storeydy.github.io\\node_modules\\@inrupt\\solid-client-authn-core\\src\\storage\\StorageUtility.ts","includedInParent":true,"mtime":1645788391053},{"name":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\storeydy.github.io\\package.json","includedInParent":true,"mtime":1645793376876},{"name":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\storeydy.github.io\\node_modules\\@inrupt\\solid-client-authn-core\\package.json","includedInParent":true,"mtime":1645788391034},{"name":"@inrupt/jose-legacy-modules","loc":{"line":7,"column":38},"parent":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\storeydy.github.io\\node_modules\\@inrupt\\solid-client-authn-core\\dist\\storage\\StorageUtility.js","resolved":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\storeydy.github.io\\node_modules\\@inrupt\\jose-legacy-modules\\dist\\index.browser.js"},{"name":"../errors/InruptError","loc":{"line":8,"column":46},"parent":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\storeydy.github.io\\node_modules\\@inrupt\\solid-client-authn-core\\dist\\storage\\StorageUtility.js","resolved":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\storeydy.github.io\\node_modules\\@inrupt\\solid-client-authn-core\\dist\\errors\\InruptError.js"}],"generated":{"js":"\"use strict\";\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.saveSessionInfoToStorage = exports.loadOidcContextFromStorage = exports.getSessionIdFromOauthState = void 0;\r\nconst jose_legacy_modules_1 = require(\"@inrupt/jose-legacy-modules\");\r\nconst InruptError_1 = __importDefault(require(\"../errors/InruptError\"));\r\nasync function getSessionIdFromOauthState(storageUtility, oauthState) {\r\n    return storageUtility.getForUser(oauthState, \"sessionId\");\r\n}\r\nexports.getSessionIdFromOauthState = getSessionIdFromOauthState;\r\nasync function loadOidcContextFromStorage(sessionId, storageUtility, configFetcher) {\r\n    try {\r\n        const [issuerIri, codeVerifier, storedRedirectIri, dpop] = await Promise.all([\r\n            storageUtility.getForUser(sessionId, \"issuer\", {\r\n                errorIfNull: true,\r\n            }),\r\n            storageUtility.getForUser(sessionId, \"codeVerifier\"),\r\n            storageUtility.getForUser(sessionId, \"redirectUrl\"),\r\n            storageUtility.getForUser(sessionId, \"dpop\", { errorIfNull: true }),\r\n        ]);\r\n        const issuerConfig = await configFetcher.fetchConfig(issuerIri);\r\n        return {\r\n            codeVerifier,\r\n            redirectUrl: storedRedirectIri,\r\n            issuerConfig,\r\n            dpop: dpop === \"true\",\r\n        };\r\n    }\r\n    catch (e) {\r\n        throw new Error(`Failed to retrieve OIDC context from storage associated with session [${sessionId}]: ${e.toString()}`);\r\n    }\r\n}\r\nexports.loadOidcContextFromStorage = loadOidcContextFromStorage;\r\nasync function saveSessionInfoToStorage(storageUtility, sessionId, idToken, webId, isLoggedIn, refreshToken, secure, dpopKey) {\r\n    if (refreshToken !== undefined) {\r\n        await storageUtility.setForUser(sessionId, { refreshToken }, { secure });\r\n    }\r\n    if (idToken !== undefined) {\r\n        await storageUtility.setForUser(sessionId, { idToken }, { secure });\r\n    }\r\n    if (webId !== undefined) {\r\n        await storageUtility.setForUser(sessionId, { webId }, { secure });\r\n    }\r\n    if (isLoggedIn !== undefined) {\r\n        await storageUtility.setForUser(sessionId, { isLoggedIn }, { secure });\r\n    }\r\n    if (dpopKey !== undefined) {\r\n        await storageUtility.setForUser(sessionId, {\r\n            publicKey: JSON.stringify(dpopKey.publicKey),\r\n            privateKey: JSON.stringify(await jose_legacy_modules_1.fromKeyLike(dpopKey.privateKey)),\r\n        }, { secure });\r\n    }\r\n}\r\nexports.saveSessionInfoToStorage = saveSessionInfoToStorage;\r\nclass StorageUtility {\r\n    constructor(secureStorage, insecureStorage) {\r\n        this.secureStorage = secureStorage;\r\n        this.insecureStorage = insecureStorage;\r\n        this.RESOURCE_SERVER_SESSION_INFORMATION_KEY = \"tmp-resource-server-session-info\";\r\n    }\r\n    getKey(userId) {\r\n        return `solidClientAuthenticationUser:${userId}`;\r\n    }\r\n    async getUserData(userId, secure) {\r\n        const stored = await (secure\r\n            ? this.secureStorage\r\n            : this.insecureStorage).get(this.getKey(userId));\r\n        if (stored === undefined) {\r\n            return {};\r\n        }\r\n        try {\r\n            return JSON.parse(stored);\r\n        }\r\n        catch (err) {\r\n            throw new InruptError_1.default(`Data for user [${userId}] in [${secure ? \"secure\" : \"unsecure\"}] storage is corrupted - expected valid JSON, but got: ${stored}`);\r\n        }\r\n    }\r\n    async setUserData(userId, data, secure) {\r\n        await (secure ? this.secureStorage : this.insecureStorage).set(this.getKey(userId), JSON.stringify(data));\r\n    }\r\n    async get(key, options) {\r\n        const value = await ((options === null || options === void 0 ? void 0 : options.secure)\r\n            ? this.secureStorage\r\n            : this.insecureStorage).get(key);\r\n        if (value === undefined && (options === null || options === void 0 ? void 0 : options.errorIfNull)) {\r\n            throw new InruptError_1.default(`[${key}] is not stored`);\r\n        }\r\n        return value;\r\n    }\r\n    async set(key, value, options) {\r\n        return ((options === null || options === void 0 ? void 0 : options.secure) ? this.secureStorage : this.insecureStorage).set(key, value);\r\n    }\r\n    async delete(key, options) {\r\n        return ((options === null || options === void 0 ? void 0 : options.secure) ? this.secureStorage : this.insecureStorage).delete(key);\r\n    }\r\n    async getForUser(userId, key, options) {\r\n        const userData = await this.getUserData(userId, options === null || options === void 0 ? void 0 : options.secure);\r\n        let value;\r\n        if (!userData || !userData[key]) {\r\n            value = undefined;\r\n        }\r\n        value = userData[key];\r\n        if (value === undefined && (options === null || options === void 0 ? void 0 : options.errorIfNull)) {\r\n            throw new InruptError_1.default(`Field [${key}] for user [${userId}] is not stored`);\r\n        }\r\n        return value || undefined;\r\n    }\r\n    async setForUser(userId, values, options) {\r\n        let userData;\r\n        try {\r\n            userData = await this.getUserData(userId, options === null || options === void 0 ? void 0 : options.secure);\r\n        }\r\n        catch (_a) {\r\n            userData = {};\r\n        }\r\n        await this.setUserData(userId, { ...userData, ...values }, options === null || options === void 0 ? void 0 : options.secure);\r\n    }\r\n    async deleteForUser(userId, key, options) {\r\n        const userData = await this.getUserData(userId, options === null || options === void 0 ? void 0 : options.secure);\r\n        delete userData[key];\r\n        await this.setUserData(userId, userData, options === null || options === void 0 ? void 0 : options.secure);\r\n    }\r\n    async deleteAllUserData(userId, options) {\r\n        await ((options === null || options === void 0 ? void 0 : options.secure) ? this.secureStorage : this.insecureStorage).delete(this.getKey(userId));\r\n    }\r\n    async storeResourceServerSessionInfo(webId, resourceServerIri, expiration) {\r\n        var _a;\r\n        const sessions = JSON.parse((_a = (await this.insecureStorage.get(this.RESOURCE_SERVER_SESSION_INFORMATION_KEY))) !== null && _a !== void 0 ? _a : \"{}\");\r\n        if (sessions.webId !== webId) {\r\n            sessions.sessions = {};\r\n        }\r\n        sessions.webId = webId;\r\n        sessions.sessions[resourceServerIri] = {\r\n            expiration,\r\n        };\r\n        await this.insecureStorage.set(this.RESOURCE_SERVER_SESSION_INFORMATION_KEY, JSON.stringify(sessions));\r\n    }\r\n    async clearResourceServerSessionInfo(resourceServerIri) {\r\n        var _a;\r\n        const sessions = JSON.parse((_a = (await this.insecureStorage.get(this.RESOURCE_SERVER_SESSION_INFORMATION_KEY))) !== null && _a !== void 0 ? _a : \"{}\");\r\n        if (sessions.sessions !== undefined) {\r\n            delete sessions.sessions[resourceServerIri];\r\n            if (Object.keys(sessions.sessions).length === 0) {\r\n                await this.insecureStorage.set(this.RESOURCE_SERVER_SESSION_INFORMATION_KEY, \"{}\");\r\n            }\r\n            else {\r\n                await this.insecureStorage.set(this.RESOURCE_SERVER_SESSION_INFORMATION_KEY, JSON.stringify(sessions));\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.default = StorageUtility;\r\n"},"sourceMaps":{"js":{"version":3,"file":"StorageUtility.js","sourceRoot":"","sources":["../../src/storage/StorageUtility.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n * Copyright 2021 Inrupt Inc.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal in\r\n * the Software without restriction, including without limitation the rights to use,\r\n * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\r\n * Software, and to permit persons to whom the Software is furnished to do so,\r\n * subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\r\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\r\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\r\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\n/**\r\n * @hidden\r\n * @packageDocumentation\r\n */\r\n\r\n/**\r\n * A helper class that will validate items taken from local storage\r\n */\r\nimport { fromKeyLike } from \"@inrupt/jose-legacy-modules\";\r\nimport IStorage from \"./IStorage\";\r\nimport IStorageUtility from \"./IStorageUtility\";\r\nimport InruptError from \"../errors/InruptError\";\r\nimport { IIssuerConfig } from \"../login/oidc/IIssuerConfig\";\r\nimport { IIssuerConfigFetcher } from \"../login/oidc/IIssuerConfigFetcher\";\r\nimport { KeyPair } from \"../authenticatedFetch/dpopUtils\";\r\n\r\nexport type OidcContext = {\r\n  issuerConfig: IIssuerConfig;\r\n  codeVerifier?: string;\r\n  redirectUrl?: string;\r\n  dpop: boolean;\r\n};\r\n\r\nexport async function getSessionIdFromOauthState(\r\n  storageUtility: IStorageUtility,\r\n  oauthState: string\r\n): Promise<string | undefined> {\r\n  return storageUtility.getForUser(oauthState, \"sessionId\");\r\n}\r\n\r\n/**\r\n * Based on the provided state, this looks up contextual information stored\r\n * before redirecting the user to the OIDC issuer.\r\n * @param sessionId The state (~ correlation ID) of the OIDC request\r\n * @param storageUtility\r\n * @param configFetcher\r\n * @returns Information stored about the client issuing the request\r\n */\r\nexport async function loadOidcContextFromStorage(\r\n  sessionId: string,\r\n  storageUtility: IStorageUtility,\r\n  configFetcher: IIssuerConfigFetcher\r\n): Promise<OidcContext> {\r\n  try {\r\n    const [issuerIri, codeVerifier, storedRedirectIri, dpop] =\r\n      await Promise.all([\r\n        storageUtility.getForUser(sessionId, \"issuer\", {\r\n          errorIfNull: true,\r\n        }),\r\n        storageUtility.getForUser(sessionId, \"codeVerifier\"),\r\n        storageUtility.getForUser(sessionId, \"redirectUrl\"),\r\n        storageUtility.getForUser(sessionId, \"dpop\", { errorIfNull: true }),\r\n      ]);\r\n\r\n    // Unlike openid-client, this looks up the configuration from storage\r\n    const issuerConfig = await configFetcher.fetchConfig(issuerIri as string);\r\n    return {\r\n      codeVerifier,\r\n      redirectUrl: storedRedirectIri,\r\n      issuerConfig,\r\n      dpop: dpop === \"true\",\r\n    };\r\n  } catch (e) {\r\n    throw new Error(\r\n      `Failed to retrieve OIDC context from storage associated with session [${sessionId}]: ${e.toString()}`\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * Stores information about the session in the provided storage. Note that not\r\n * all storage are equally secure, and it is strongly advised not to store either\r\n * the refresh token or the DPoP key in the browser's local storage.\r\n *\r\n * @param storageUtility\r\n * @param sessionId\r\n * @param idToken\r\n * @param webId\r\n * @param isLoggedIn\r\n * @param refreshToken\r\n * @param secure\r\n * @param dpopKey\r\n */\r\nexport async function saveSessionInfoToStorage(\r\n  storageUtility: IStorageUtility,\r\n  sessionId: string,\r\n  idToken?: string,\r\n  webId?: string,\r\n  isLoggedIn?: string,\r\n  refreshToken?: string,\r\n  secure?: boolean,\r\n  dpopKey?: KeyPair\r\n): Promise<void> {\r\n  // TODO: Investigate why this does not work with a Promise.all\r\n  if (refreshToken !== undefined) {\r\n    await storageUtility.setForUser(sessionId, { refreshToken }, { secure });\r\n  }\r\n  if (idToken !== undefined) {\r\n    await storageUtility.setForUser(sessionId, { idToken }, { secure });\r\n  }\r\n  if (webId !== undefined) {\r\n    await storageUtility.setForUser(sessionId, { webId }, { secure });\r\n  }\r\n  if (isLoggedIn !== undefined) {\r\n    await storageUtility.setForUser(sessionId, { isLoggedIn }, { secure });\r\n  }\r\n  if (dpopKey !== undefined) {\r\n    await storageUtility.setForUser(\r\n      sessionId,\r\n      {\r\n        publicKey: JSON.stringify(dpopKey.publicKey),\r\n        privateKey: JSON.stringify(await fromKeyLike(dpopKey.privateKey)),\r\n      },\r\n      { secure }\r\n    );\r\n  }\r\n}\r\n\r\nexport type ResourceServerSession = {\r\n  webId: string;\r\n  sessions: Record<\r\n    string,\r\n    {\r\n      expiration: number;\r\n    }\r\n  >;\r\n};\r\n\r\n// TOTEST: this does not handle all possible bad inputs for example what if it's not proper JSON\r\n/**\r\n * @hidden\r\n */\r\nexport default class StorageUtility implements IStorageUtility {\r\n  constructor(\r\n    private secureStorage: IStorage,\r\n    private insecureStorage: IStorage\r\n  ) {}\r\n\r\n  private getKey(userId: string): string {\r\n    return `solidClientAuthenticationUser:${userId}`;\r\n  }\r\n\r\n  private RESOURCE_SERVER_SESSION_INFORMATION_KEY =\r\n    \"tmp-resource-server-session-info\";\r\n\r\n  private async getUserData(\r\n    userId: string,\r\n    secure?: boolean\r\n  ): Promise<Record<string, string>> {\r\n    const stored = await (secure\r\n      ? this.secureStorage\r\n      : this.insecureStorage\r\n    ).get(this.getKey(userId));\r\n\r\n    if (stored === undefined) {\r\n      return {};\r\n    }\r\n\r\n    try {\r\n      return JSON.parse(stored);\r\n    } catch (err) {\r\n      throw new InruptError(\r\n        `Data for user [${userId}] in [${\r\n          secure ? \"secure\" : \"unsecure\"\r\n        }] storage is corrupted - expected valid JSON, but got: ${stored}`\r\n      );\r\n    }\r\n  }\r\n\r\n  private async setUserData(\r\n    userId: string,\r\n    data: Record<string, string>,\r\n    secure?: boolean\r\n  ): Promise<void> {\r\n    await (secure ? this.secureStorage : this.insecureStorage).set(\r\n      this.getKey(userId),\r\n      JSON.stringify(data)\r\n    );\r\n  }\r\n\r\n  async get(\r\n    key: string,\r\n    options?: { errorIfNull?: boolean; secure?: boolean }\r\n  ): Promise<string | undefined> {\r\n    const value = await (options?.secure\r\n      ? this.secureStorage\r\n      : this.insecureStorage\r\n    ).get(key);\r\n    if (value === undefined && options?.errorIfNull) {\r\n      throw new InruptError(`[${key}] is not stored`);\r\n    }\r\n    return value;\r\n  }\r\n\r\n  async set(\r\n    key: string,\r\n    value: string,\r\n    options?: { secure?: boolean }\r\n  ): Promise<void> {\r\n    return (options?.secure ? this.secureStorage : this.insecureStorage).set(\r\n      key,\r\n      value\r\n    );\r\n  }\r\n\r\n  async delete(key: string, options?: { secure?: boolean }): Promise<void> {\r\n    return (options?.secure ? this.secureStorage : this.insecureStorage).delete(\r\n      key\r\n    );\r\n  }\r\n\r\n  async getForUser(\r\n    userId: string,\r\n    key: string,\r\n    options?: { errorIfNull?: boolean; secure?: boolean }\r\n  ): Promise<string | undefined> {\r\n    const userData = await this.getUserData(userId, options?.secure);\r\n    let value;\r\n    if (!userData || !userData[key]) {\r\n      value = undefined;\r\n    }\r\n    value = userData[key];\r\n    if (value === undefined && options?.errorIfNull) {\r\n      throw new InruptError(\r\n        `Field [${key}] for user [${userId}] is not stored`\r\n      );\r\n    }\r\n    return value || undefined;\r\n  }\r\n\r\n  async setForUser(\r\n    userId: string,\r\n    values: Record<string, string>,\r\n    options?: { secure?: boolean }\r\n  ): Promise<void> {\r\n    let userData: Record<string, string>;\r\n    try {\r\n      userData = await this.getUserData(userId, options?.secure);\r\n    } catch {\r\n      // if reading the user data throws, the data is corrupted, and we want to write over it\r\n      userData = {};\r\n    }\r\n\r\n    await this.setUserData(userId, { ...userData, ...values }, options?.secure);\r\n  }\r\n\r\n  async deleteForUser(\r\n    userId: string,\r\n    key: string,\r\n    options?: { secure?: boolean }\r\n  ): Promise<void> {\r\n    const userData = await this.getUserData(userId, options?.secure);\r\n    delete userData[key];\r\n    await this.setUserData(userId, userData, options?.secure);\r\n  }\r\n\r\n  async deleteAllUserData(\r\n    userId: string,\r\n    options?: { secure?: boolean }\r\n  ): Promise<void> {\r\n    await (options?.secure ? this.secureStorage : this.insecureStorage).delete(\r\n      this.getKey(userId)\r\n    );\r\n  }\r\n\r\n  async storeResourceServerSessionInfo(\r\n    webId: string,\r\n    resourceServerIri: string,\r\n    expiration: number\r\n  ): Promise<void> {\r\n    const sessions: ResourceServerSession = JSON.parse(\r\n      (await this.insecureStorage.get(\r\n        this.RESOURCE_SERVER_SESSION_INFORMATION_KEY\r\n      )) ?? \"{}\"\r\n    );\r\n    if (sessions.webId !== webId) {\r\n      // Clear all previously active sessions.\r\n      sessions.sessions = {};\r\n    }\r\n    sessions.webId = webId;\r\n    sessions.sessions[resourceServerIri] = {\r\n      expiration,\r\n    };\r\n    await this.insecureStorage.set(\r\n      this.RESOURCE_SERVER_SESSION_INFORMATION_KEY,\r\n      JSON.stringify(sessions)\r\n    );\r\n  }\r\n\r\n  async clearResourceServerSessionInfo(\r\n    resourceServerIri: string\r\n  ): Promise<void> {\r\n    const sessions: ResourceServerSession = JSON.parse(\r\n      (await this.insecureStorage.get(\r\n        this.RESOURCE_SERVER_SESSION_INFORMATION_KEY\r\n      )) ?? \"{}\"\r\n    );\r\n    if (sessions.sessions !== undefined) {\r\n      delete sessions.sessions[resourceServerIri];\r\n\r\n      if (Object.keys(sessions.sessions).length === 0) {\r\n        // If there aren't any active sessions left, the whole object is cleared.\r\n        await this.insecureStorage.set(\r\n          this.RESOURCE_SERVER_SESSION_INFORMATION_KEY,\r\n          \"{}\"\r\n        );\r\n      } else {\r\n        await this.insecureStorage.set(\r\n          this.RESOURCE_SERVER_SESSION_INFORMATION_KEY,\r\n          JSON.stringify(sessions)\r\n        );\r\n      }\r\n    }\r\n  }\r\n}\r\n"]}},"error":null,"hash":"073fa5129d8b00957525eb733551a196","cacheData":{"env":{}}}