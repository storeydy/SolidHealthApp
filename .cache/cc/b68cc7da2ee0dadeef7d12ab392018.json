{"id":"node_modules/@inrupt/solid-client-authn-browser/dist/login/oidc/redirectHandler/AuthCodeRedirectHandler.js","dependencies":[{"name":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\storeydy.github.io\\node_modules\\@inrupt\\solid-client-authn-browser\\dist\\login\\oidc\\redirectHandler\\AuthCodeRedirectHandler.js.map","includedInParent":true,"mtime":1645788390857},{"name":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\storeydy.github.io\\node_modules\\@inrupt\\solid-client-authn-browser\\src\\login\\oidc\\redirectHandler\\AuthCodeRedirectHandler.ts","includedInParent":true,"mtime":1645788390962},{"name":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\storeydy.github.io\\package.json","includedInParent":true,"mtime":1645793376876},{"name":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\storeydy.github.io\\node_modules\\@inrupt\\solid-client-authn-browser\\package.json","includedInParent":true,"mtime":1645788390926},{"name":"@inrupt/solid-client-authn-core","loc":{"line":4,"column":42},"parent":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\storeydy.github.io\\node_modules\\@inrupt\\solid-client-authn-browser\\dist\\login\\oidc\\redirectHandler\\AuthCodeRedirectHandler.js","resolved":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\storeydy.github.io\\node_modules\\@inrupt\\solid-client-authn-core\\dist\\index.js"},{"name":"@inrupt/oidc-client-ext","loc":{"line":5,"column":34},"parent":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\storeydy.github.io\\node_modules\\@inrupt\\solid-client-authn-browser\\dist\\login\\oidc\\redirectHandler\\AuthCodeRedirectHandler.js","resolved":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\storeydy.github.io\\node_modules\\@inrupt\\oidc-client-ext\\dist\\index.es.js"},{"name":"../../../constant","loc":{"line":6,"column":27},"parent":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\storeydy.github.io\\node_modules\\@inrupt\\solid-client-authn-browser\\dist\\login\\oidc\\redirectHandler\\AuthCodeRedirectHandler.js","resolved":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\storeydy.github.io\\node_modules\\@inrupt\\solid-client-authn-browser\\dist\\constant.js"}],"generated":{"js":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.AuthCodeRedirectHandler = exports.DEFAULT_LIFESPAN = void 0;\r\nconst solid_client_authn_core_1 = require(\"@inrupt/solid-client-authn-core\");\r\nconst oidc_client_ext_1 = require(\"@inrupt/oidc-client-ext\");\r\nconst constant_1 = require(\"../../../constant\");\r\nexports.DEFAULT_LIFESPAN = 30 * 60 * 1000;\r\nasync function setupResourceServerSession(webId, authenticatedFetch, storageUtility) {\r\n    const webIdAsUrl = new URL(webId);\r\n    const resourceServerIri = webIdAsUrl.origin;\r\n    await authenticatedFetch(webId);\r\n    try {\r\n        const resourceServerResponse = await authenticatedFetch(`${resourceServerIri}/session`);\r\n        if (resourceServerResponse.status === 200) {\r\n            await storageUtility.storeResourceServerSessionInfo(webId, resourceServerIri, Date.now() + exports.DEFAULT_LIFESPAN);\r\n            return;\r\n        }\r\n        await storageUtility.clearResourceServerSessionInfo(resourceServerIri);\r\n    }\r\n    catch (_e) {\r\n        await storageUtility.clearResourceServerSessionInfo(resourceServerIri);\r\n    }\r\n}\r\nclass AuthCodeRedirectHandler {\r\n    constructor(storageUtility, sessionInfoManager, issuerConfigFetcher, clientRegistrar, tokerRefresher) {\r\n        this.storageUtility = storageUtility;\r\n        this.sessionInfoManager = sessionInfoManager;\r\n        this.issuerConfigFetcher = issuerConfigFetcher;\r\n        this.clientRegistrar = clientRegistrar;\r\n        this.tokerRefresher = tokerRefresher;\r\n    }\r\n    async canHandle(redirectUrl) {\r\n        try {\r\n            const myUrl = new URL(redirectUrl);\r\n            return (myUrl.searchParams.get(\"code\") !== null &&\r\n                myUrl.searchParams.get(\"state\") !== null);\r\n        }\r\n        catch (e) {\r\n            throw new Error(`[${redirectUrl}] is not a valid URL, and cannot be used as a redirect URL: ${e.toString()}`);\r\n        }\r\n    }\r\n    async handle(redirectUrl, eventEmitter) {\r\n        if (!(await this.canHandle(redirectUrl))) {\r\n            throw new Error(`AuthCodeRedirectHandler cannot handle [${redirectUrl}]: it is missing one of [code, state].`);\r\n        }\r\n        const url = new URL(redirectUrl);\r\n        const oauthState = url.searchParams.get(\"state\");\r\n        const storedSessionId = (await this.storageUtility.getForUser(oauthState, \"sessionId\", {\r\n            errorIfNull: true,\r\n        }));\r\n        const isDpop = (await this.storageUtility.getForUser(storedSessionId, \"dpop\")) ===\r\n            \"true\";\r\n        const issuer = (await this.storageUtility.getForUser(storedSessionId, \"issuer\", { errorIfNull: true }));\r\n        window.localStorage.setItem(constant_1.KEY_CURRENT_SESSION, storedSessionId);\r\n        const issuerConfig = await this.issuerConfigFetcher.fetchConfig(issuer);\r\n        const client = await this.clientRegistrar.getClient({ sessionId: storedSessionId }, issuerConfig);\r\n        let tokens;\r\n        const referenceTime = Date.now();\r\n        if (isDpop) {\r\n            const codeVerifier = (await this.storageUtility.getForUser(storedSessionId, \"codeVerifier\", { errorIfNull: true }));\r\n            const storedRedirectIri = (await this.storageUtility.getForUser(storedSessionId, \"redirectUrl\", { errorIfNull: true }));\r\n            tokens = await oidc_client_ext_1.getDpopToken(issuerConfig, client, {\r\n                grantType: \"authorization_code\",\r\n                code: url.searchParams.get(\"code\"),\r\n                codeVerifier,\r\n                redirectUrl: storedRedirectIri,\r\n            });\r\n        }\r\n        else {\r\n            tokens = await oidc_client_ext_1.getBearerToken(url.toString());\r\n        }\r\n        let refreshOptions;\r\n        if (tokens.refreshToken !== undefined) {\r\n            refreshOptions = {\r\n                sessionId: storedSessionId,\r\n                refreshToken: tokens.refreshToken,\r\n                tokenRefresher: this.tokerRefresher,\r\n            };\r\n        }\r\n        const authFetch = await solid_client_authn_core_1.buildAuthenticatedFetch(fetch, tokens.accessToken, {\r\n            dpopKey: tokens.dpopKey,\r\n            refreshOptions,\r\n            eventEmitter,\r\n            expiresIn: tokens.expiresIn,\r\n        });\r\n        await this.storageUtility.setForUser(storedSessionId, {\r\n            refreshToken: \"<Refresh token that *is* coming back in the redirect URL is not yet being parsed and provided by oidc-client-js in it's response object>\",\r\n            webId: tokens.webId,\r\n            isLoggedIn: \"true\",\r\n        }, { secure: true });\r\n        url.searchParams.delete(\"code\");\r\n        await this.storageUtility.setForUser(storedSessionId, {\r\n            redirectUrl: url.toString(),\r\n            idToken: tokens.idToken,\r\n        }, {\r\n            secure: false,\r\n        });\r\n        const essWorkaroundDisabled = window.localStorage.getItem(\"tmp-resource-server-session-enabled\") ===\r\n            \"false\";\r\n        if (!essWorkaroundDisabled) {\r\n            await setupResourceServerSession(tokens.webId, authFetch, this.storageUtility);\r\n        }\r\n        const sessionInfo = await this.sessionInfoManager.get(storedSessionId);\r\n        if (!sessionInfo) {\r\n            throw new Error(`Could not retrieve session: [${storedSessionId}].`);\r\n        }\r\n        return Object.assign(sessionInfo, {\r\n            fetch: authFetch,\r\n            expirationDate: typeof tokens.expiresIn === \"number\"\r\n                ? referenceTime + tokens.expiresIn * 1000\r\n                : null,\r\n        });\r\n    }\r\n}\r\nexports.AuthCodeRedirectHandler = AuthCodeRedirectHandler;\r\n"},"sourceMaps":{"js":{"version":3,"file":"AuthCodeRedirectHandler.js","sourceRoot":"","sources":["../../../../src/login/oidc/redirectHandler/AuthCodeRedirectHandler.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n * Copyright 2021 Inrupt Inc.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal in\r\n * the Software without restriction, including without limitation the rights to use,\r\n * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\r\n * Software, and to permit persons to whom the Software is furnished to do so,\r\n * subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\r\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\r\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\r\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\n/**\r\n * @hidden\r\n * @packageDocumentation\r\n */\r\n\r\nimport {\r\n  buildAuthenticatedFetch,\r\n  IClient,\r\n  IClientRegistrar,\r\n  IIssuerConfigFetcher,\r\n  IRedirectHandler,\r\n  ISessionInfo,\r\n  ISessionInfoManager,\r\n  IStorageUtility,\r\n  ITokenRefresher,\r\n  RefreshOptions,\r\n} from \"@inrupt/solid-client-authn-core\";\r\nimport {\r\n  getDpopToken,\r\n  getBearerToken,\r\n  CodeExchangeResult,\r\n} from \"@inrupt/oidc-client-ext\";\r\nimport { EventEmitter } from \"events\";\r\nimport { KEY_CURRENT_SESSION } from \"../../../constant\";\r\n\r\n// A lifespan of 30 minutes is ESS's default. This could be removed if we\r\n// configure the server to return the remaining lifespan of the cookie.\r\nexport const DEFAULT_LIFESPAN = 30 * 60 * 1000;\r\n\r\n/**\r\n * Stores the resource server session information in local storage, so that they\r\n * can be used on refresh.\r\n * @param webId\r\n * @param authenticatedFetch\r\n * @param storageUtility\r\n */\r\nasync function setupResourceServerSession(\r\n  webId: string,\r\n  authenticatedFetch: typeof fetch,\r\n  storageUtility: IStorageUtility\r\n): Promise<void> {\r\n  const webIdAsUrl = new URL(webId);\r\n  const resourceServerIri = webIdAsUrl.origin;\r\n  // Querying the /session endpoint does not set the cookie, but issuing an\r\n  // authenticated request to any actual resource (even public ones) does,\r\n  // so we fetch the user's WebID before checking the /session endpoint.\r\n  await authenticatedFetch(webId);\r\n  try {\r\n    const resourceServerResponse = await authenticatedFetch(\r\n      `${resourceServerIri}/session`\r\n    );\r\n\r\n    if (resourceServerResponse.status === 200) {\r\n      await storageUtility.storeResourceServerSessionInfo(\r\n        webId,\r\n        resourceServerIri,\r\n        // Note that here, if the lifespan of the cookie was returned by the\r\n        // server, we'd expect a relative value (the remaining time of validity)\r\n        // rather than an absolute one (the moment when the cookie expires).\r\n        Date.now() + DEFAULT_LIFESPAN\r\n      );\r\n      return;\r\n    }\r\n    // In this case, the resource server either:\r\n    // - does not have the expected endpoint, or\r\n    // - does not recognize the user\r\n    // Either way, no cookie is expected to be set there, and any existing\r\n    // session information should be cleared.\r\n    await storageUtility.clearResourceServerSessionInfo(resourceServerIri);\r\n  } catch (_e) {\r\n    // Setting the `credentials=include` option on fetch, which is required in\r\n    // the current approach based on a RS cookie, may result in an error if\r\n    // attempting to access an URL, depending on the CORS policies.\r\n    // Since this internal fetch is necessary, and out of control of the\r\n    // calling library, there is no other solution but to swallow the exception.\r\n    // This may happen depending on how the target RS handles a request to the\r\n    // /session endpoint.\r\n    await storageUtility.clearResourceServerSessionInfo(resourceServerIri);\r\n  }\r\n}\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport class AuthCodeRedirectHandler implements IRedirectHandler {\r\n  constructor(\r\n    private storageUtility: IStorageUtility,\r\n    private sessionInfoManager: ISessionInfoManager,\r\n    private issuerConfigFetcher: IIssuerConfigFetcher,\r\n    private clientRegistrar: IClientRegistrar,\r\n    private tokerRefresher: ITokenRefresher\r\n  ) {}\r\n\r\n  async canHandle(redirectUrl: string): Promise<boolean> {\r\n    try {\r\n      const myUrl = new URL(redirectUrl);\r\n      return (\r\n        myUrl.searchParams.get(\"code\") !== null &&\r\n        myUrl.searchParams.get(\"state\") !== null\r\n      );\r\n    } catch (e) {\r\n      throw new Error(\r\n        `[${redirectUrl}] is not a valid URL, and cannot be used as a redirect URL: ${e.toString()}`\r\n      );\r\n    }\r\n  }\r\n\r\n  async handle(\r\n    redirectUrl: string,\r\n    eventEmitter?: EventEmitter\r\n  ): Promise<ISessionInfo & { fetch: typeof fetch }> {\r\n    if (!(await this.canHandle(redirectUrl))) {\r\n      throw new Error(\r\n        `AuthCodeRedirectHandler cannot handle [${redirectUrl}]: it is missing one of [code, state].`\r\n      );\r\n    }\r\n\r\n    const url = new URL(redirectUrl);\r\n    const oauthState = url.searchParams.get(\"state\") as string;\r\n\r\n    const storedSessionId = (await this.storageUtility.getForUser(\r\n      oauthState,\r\n      \"sessionId\",\r\n      {\r\n        errorIfNull: true,\r\n      }\r\n    )) as string;\r\n    const isDpop =\r\n      (await this.storageUtility.getForUser(storedSessionId, \"dpop\")) ===\r\n      \"true\";\r\n\r\n    // Since we throw if not found, the type assertion is okay\r\n    const issuer = (await this.storageUtility.getForUser(\r\n      storedSessionId,\r\n      \"issuer\",\r\n      { errorIfNull: true }\r\n    )) as string;\r\n\r\n    // Store the current session ID specifically in 'localStorage' (i.e., not using\r\n    // any other storage mechanism), as we don't deem this information to be\r\n    // sensitive, and we want to ensure it survives a browser tab refresh.\r\n    window.localStorage.setItem(KEY_CURRENT_SESSION, storedSessionId);\r\n\r\n    const issuerConfig = await this.issuerConfigFetcher.fetchConfig(issuer);\r\n    const client: IClient = await this.clientRegistrar.getClient(\r\n      { sessionId: storedSessionId },\r\n      issuerConfig\r\n    );\r\n\r\n    let tokens: CodeExchangeResult;\r\n    const referenceTime = Date.now();\r\n\r\n    if (isDpop) {\r\n      const codeVerifier = (await this.storageUtility.getForUser(\r\n        storedSessionId,\r\n        \"codeVerifier\",\r\n        { errorIfNull: true }\r\n      )) as string;\r\n\r\n      const storedRedirectIri = (await this.storageUtility.getForUser(\r\n        storedSessionId,\r\n        \"redirectUrl\",\r\n        { errorIfNull: true }\r\n      )) as string;\r\n\r\n      tokens = await getDpopToken(issuerConfig, client, {\r\n        grantType: \"authorization_code\",\r\n        // We rely on our 'canHandle' function checking that the OAuth 'code'\r\n        // parameter is present in our query string.\r\n        code: url.searchParams.get(\"code\") as string,\r\n        codeVerifier,\r\n        redirectUrl: storedRedirectIri,\r\n      });\r\n    } else {\r\n      tokens = await getBearerToken(url.toString());\r\n    }\r\n\r\n    let refreshOptions: RefreshOptions | undefined;\r\n    if (tokens.refreshToken !== undefined) {\r\n      refreshOptions = {\r\n        sessionId: storedSessionId,\r\n        refreshToken: tokens.refreshToken,\r\n        tokenRefresher: this.tokerRefresher,\r\n      };\r\n    }\r\n\r\n    const authFetch = await buildAuthenticatedFetch(fetch, tokens.accessToken, {\r\n      dpopKey: tokens.dpopKey,\r\n      refreshOptions,\r\n      eventEmitter,\r\n      expiresIn: tokens.expiresIn,\r\n    });\r\n\r\n    await this.storageUtility.setForUser(\r\n      storedSessionId,\r\n      {\r\n        // TODO: We need a PR to oidc-client-js to add parsing of the\r\n        //  refresh_token from the redirect URL.\r\n        refreshToken:\r\n          \"<Refresh token that *is* coming back in the redirect URL is not yet being parsed and provided by oidc-client-js in it's response object>\",\r\n        webId: tokens.webId,\r\n        isLoggedIn: \"true\",\r\n      },\r\n      { secure: true }\r\n    );\r\n    // Clear the code query param from the redirect URL before storing it, but\r\n    // preserve any state that my have been provided by the client and returned\r\n    // by the IdP.\r\n    url.searchParams.delete(\"code\");\r\n    await this.storageUtility.setForUser(\r\n      storedSessionId,\r\n      {\r\n        redirectUrl: url.toString(),\r\n        idToken: tokens.idToken,\r\n      },\r\n      {\r\n        secure: false,\r\n      }\r\n    );\r\n    // TODO: This is a temporary workaround. When deprecating the cookie-based auth,\r\n    // this should be all cleared.\r\n    const essWorkaroundDisabled =\r\n      window.localStorage.getItem(\"tmp-resource-server-session-enabled\") ===\r\n      \"false\";\r\n    if (!essWorkaroundDisabled) {\r\n      await setupResourceServerSession(\r\n        tokens.webId,\r\n        authFetch,\r\n        this.storageUtility\r\n      );\r\n    }\r\n\r\n    const sessionInfo = await this.sessionInfoManager.get(storedSessionId);\r\n    if (!sessionInfo) {\r\n      throw new Error(`Could not retrieve session: [${storedSessionId}].`);\r\n    }\r\n\r\n    return Object.assign(sessionInfo, {\r\n      fetch: authFetch,\r\n      expirationDate:\r\n        typeof tokens.expiresIn === \"number\"\r\n          ? referenceTime + tokens.expiresIn * 1000\r\n          : null,\r\n    });\r\n  }\r\n}\r\n"]}},"error":null,"hash":"36f4b344025c9d5faf580f6bde20b387","cacheData":{"env":{}}}