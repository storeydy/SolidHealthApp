{"id":"node_modules/@inrupt/solid-client-authn-browser/dist/login/oidc/redirectHandler/AuthCodeRedirectHandler.js","dependencies":[{"name":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\solid-health-app\\inrupt-solid-app\\node_modules\\@inrupt\\solid-client-authn-browser\\dist\\login\\oidc\\redirectHandler\\AuthCodeRedirectHandler.js.map","includedInParent":true,"mtime":499162500000},{"name":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\solid-health-app\\inrupt-solid-app\\node_modules\\@inrupt\\solid-client-authn-browser\\src\\login\\oidc\\redirectHandler\\AuthCodeRedirectHandler.ts","includedInParent":true,"mtime":499162500000},{"name":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\solid-health-app\\inrupt-solid-app\\package.json","includedInParent":true,"mtime":1643281048105},{"name":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\solid-health-app\\inrupt-solid-app\\node_modules\\@inrupt\\solid-client-authn-browser\\package.json","includedInParent":true,"mtime":1643233902805},{"name":"@inrupt/solid-client-authn-core","loc":{"line":4,"column":42},"parent":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\solid-health-app\\inrupt-solid-app\\node_modules\\@inrupt\\solid-client-authn-browser\\dist\\login\\oidc\\redirectHandler\\AuthCodeRedirectHandler.js","resolved":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\solid-health-app\\inrupt-solid-app\\node_modules\\@inrupt\\solid-client-authn-core\\dist\\index.js"},{"name":"@inrupt/oidc-client-ext","loc":{"line":5,"column":34},"parent":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\solid-health-app\\inrupt-solid-app\\node_modules\\@inrupt\\solid-client-authn-browser\\dist\\login\\oidc\\redirectHandler\\AuthCodeRedirectHandler.js","resolved":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\solid-health-app\\inrupt-solid-app\\node_modules\\@inrupt\\oidc-client-ext\\dist\\index.es.js"},{"name":"../../../constant","loc":{"line":6,"column":27},"parent":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\solid-health-app\\inrupt-solid-app\\node_modules\\@inrupt\\solid-client-authn-browser\\dist\\login\\oidc\\redirectHandler\\AuthCodeRedirectHandler.js","resolved":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\solid-health-app\\inrupt-solid-app\\node_modules\\@inrupt\\solid-client-authn-browser\\dist\\constant.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AuthCodeRedirectHandler = exports.DEFAULT_LIFESPAN = void 0;\nconst solid_client_authn_core_1 = require(\"@inrupt/solid-client-authn-core\");\nconst oidc_client_ext_1 = require(\"@inrupt/oidc-client-ext\");\nconst constant_1 = require(\"../../../constant\");\nexports.DEFAULT_LIFESPAN = 30 * 60 * 1000;\nasync function setupResourceServerSession(webId, authenticatedFetch, storageUtility) {\n    const webIdAsUrl = new URL(webId);\n    const resourceServerIri = webIdAsUrl.origin;\n    await authenticatedFetch(webId);\n    try {\n        const resourceServerResponse = await authenticatedFetch(`${resourceServerIri}/session`);\n        if (resourceServerResponse.status === 200) {\n            await storageUtility.storeResourceServerSessionInfo(webId, resourceServerIri, Date.now() + exports.DEFAULT_LIFESPAN);\n            return;\n        }\n        await storageUtility.clearResourceServerSessionInfo(resourceServerIri);\n    }\n    catch (_e) {\n        await storageUtility.clearResourceServerSessionInfo(resourceServerIri);\n    }\n}\nclass AuthCodeRedirectHandler {\n    constructor(storageUtility, sessionInfoManager, issuerConfigFetcher, clientRegistrar, tokerRefresher) {\n        this.storageUtility = storageUtility;\n        this.sessionInfoManager = sessionInfoManager;\n        this.issuerConfigFetcher = issuerConfigFetcher;\n        this.clientRegistrar = clientRegistrar;\n        this.tokerRefresher = tokerRefresher;\n    }\n    async canHandle(redirectUrl) {\n        try {\n            const myUrl = new URL(redirectUrl);\n            return (myUrl.searchParams.get(\"code\") !== null &&\n                myUrl.searchParams.get(\"state\") !== null);\n        }\n        catch (e) {\n            throw new Error(`[${redirectUrl}] is not a valid URL, and cannot be used as a redirect URL: ${e.toString()}`);\n        }\n    }\n    async handle(redirectUrl, eventEmitter) {\n        if (!(await this.canHandle(redirectUrl))) {\n            throw new Error(`AuthCodeRedirectHandler cannot handle [${redirectUrl}]: it is missing one of [code, state].`);\n        }\n        const url = new URL(redirectUrl);\n        const oauthState = url.searchParams.get(\"state\");\n        const storedSessionId = (await this.storageUtility.getForUser(oauthState, \"sessionId\", {\n            errorIfNull: true,\n        }));\n        const isDpop = (await this.storageUtility.getForUser(storedSessionId, \"dpop\")) ===\n            \"true\";\n        const issuer = (await this.storageUtility.getForUser(storedSessionId, \"issuer\", { errorIfNull: true }));\n        window.localStorage.setItem(constant_1.KEY_CURRENT_SESSION, storedSessionId);\n        const issuerConfig = await this.issuerConfigFetcher.fetchConfig(issuer);\n        const client = await this.clientRegistrar.getClient({ sessionId: storedSessionId }, issuerConfig);\n        let tokens;\n        const referenceTime = Date.now();\n        if (isDpop) {\n            const codeVerifier = (await this.storageUtility.getForUser(storedSessionId, \"codeVerifier\", { errorIfNull: true }));\n            const storedRedirectIri = (await this.storageUtility.getForUser(storedSessionId, \"redirectUrl\", { errorIfNull: true }));\n            tokens = await oidc_client_ext_1.getDpopToken(issuerConfig, client, {\n                grantType: \"authorization_code\",\n                code: url.searchParams.get(\"code\"),\n                codeVerifier,\n                redirectUrl: storedRedirectIri,\n            });\n        }\n        else {\n            tokens = await oidc_client_ext_1.getBearerToken(url.toString());\n        }\n        let refreshOptions;\n        if (tokens.refreshToken !== undefined) {\n            refreshOptions = {\n                sessionId: storedSessionId,\n                refreshToken: tokens.refreshToken,\n                tokenRefresher: this.tokerRefresher,\n            };\n        }\n        const authFetch = await solid_client_authn_core_1.buildAuthenticatedFetch(fetch, tokens.accessToken, {\n            dpopKey: tokens.dpopKey,\n            refreshOptions,\n            eventEmitter,\n            expiresIn: tokens.expiresIn,\n        });\n        await this.storageUtility.setForUser(storedSessionId, {\n            refreshToken: \"<Refresh token that *is* coming back in the redirect URL is not yet being parsed and provided by oidc-client-js in it's response object>\",\n            webId: tokens.webId,\n            isLoggedIn: \"true\",\n        }, { secure: true });\n        url.searchParams.delete(\"code\");\n        await this.storageUtility.setForUser(storedSessionId, {\n            redirectUrl: url.toString(),\n            idToken: tokens.idToken,\n        }, {\n            secure: false,\n        });\n        const essWorkaroundDisabled = window.localStorage.getItem(\"tmp-resource-server-session-enabled\") ===\n            \"false\";\n        if (!essWorkaroundDisabled) {\n            await setupResourceServerSession(tokens.webId, authFetch, this.storageUtility);\n        }\n        const sessionInfo = await this.sessionInfoManager.get(storedSessionId);\n        if (!sessionInfo) {\n            throw new Error(`Could not retrieve session: [${storedSessionId}].`);\n        }\n        return Object.assign(sessionInfo, {\n            fetch: authFetch,\n            expirationDate: typeof tokens.expiresIn === \"number\"\n                ? referenceTime + tokens.expiresIn * 1000\n                : null,\n        });\n    }\n}\nexports.AuthCodeRedirectHandler = AuthCodeRedirectHandler;\n"},"sourceMaps":{"js":{"version":3,"file":"AuthCodeRedirectHandler.js","sourceRoot":"","sources":["../../../../src/login/oidc/redirectHandler/AuthCodeRedirectHandler.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright 2021 Inrupt Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n * Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * @hidden\n * @packageDocumentation\n */\n\nimport {\n  buildAuthenticatedFetch,\n  IClient,\n  IClientRegistrar,\n  IIssuerConfigFetcher,\n  IRedirectHandler,\n  ISessionInfo,\n  ISessionInfoManager,\n  IStorageUtility,\n  ITokenRefresher,\n  RefreshOptions,\n} from \"@inrupt/solid-client-authn-core\";\nimport {\n  getDpopToken,\n  getBearerToken,\n  CodeExchangeResult,\n} from \"@inrupt/oidc-client-ext\";\nimport { EventEmitter } from \"events\";\nimport { KEY_CURRENT_SESSION } from \"../../../constant\";\n\n// A lifespan of 30 minutes is ESS's default. This could be removed if we\n// configure the server to return the remaining lifespan of the cookie.\nexport const DEFAULT_LIFESPAN = 30 * 60 * 1000;\n\n/**\n * Stores the resource server session information in local storage, so that they\n * can be used on refresh.\n * @param webId\n * @param authenticatedFetch\n * @param storageUtility\n */\nasync function setupResourceServerSession(\n  webId: string,\n  authenticatedFetch: typeof fetch,\n  storageUtility: IStorageUtility\n): Promise<void> {\n  const webIdAsUrl = new URL(webId);\n  const resourceServerIri = webIdAsUrl.origin;\n  // Querying the /session endpoint does not set the cookie, but issuing an\n  // authenticated request to any actual resource (even public ones) does,\n  // so we fetch the user's WebID before checking the /session endpoint.\n  await authenticatedFetch(webId);\n  try {\n    const resourceServerResponse = await authenticatedFetch(\n      `${resourceServerIri}/session`\n    );\n\n    if (resourceServerResponse.status === 200) {\n      await storageUtility.storeResourceServerSessionInfo(\n        webId,\n        resourceServerIri,\n        // Note that here, if the lifespan of the cookie was returned by the\n        // server, we'd expect a relative value (the remaining time of validity)\n        // rather than an absolute one (the moment when the cookie expires).\n        Date.now() + DEFAULT_LIFESPAN\n      );\n      return;\n    }\n    // In this case, the resource server either:\n    // - does not have the expected endpoint, or\n    // - does not recognize the user\n    // Either way, no cookie is expected to be set there, and any existing\n    // session information should be cleared.\n    await storageUtility.clearResourceServerSessionInfo(resourceServerIri);\n  } catch (_e) {\n    // Setting the `credentials=include` option on fetch, which is required in\n    // the current approach based on a RS cookie, may result in an error if\n    // attempting to access an URL, depending on the CORS policies.\n    // Since this internal fetch is necessary, and out of control of the\n    // calling library, there is no other solution but to swallow the exception.\n    // This may happen depending on how the target RS handles a request to the\n    // /session endpoint.\n    await storageUtility.clearResourceServerSessionInfo(resourceServerIri);\n  }\n}\n\n/**\n * @hidden\n */\nexport class AuthCodeRedirectHandler implements IRedirectHandler {\n  constructor(\n    private storageUtility: IStorageUtility,\n    private sessionInfoManager: ISessionInfoManager,\n    private issuerConfigFetcher: IIssuerConfigFetcher,\n    private clientRegistrar: IClientRegistrar,\n    private tokerRefresher: ITokenRefresher\n  ) {}\n\n  async canHandle(redirectUrl: string): Promise<boolean> {\n    try {\n      const myUrl = new URL(redirectUrl);\n      return (\n        myUrl.searchParams.get(\"code\") !== null &&\n        myUrl.searchParams.get(\"state\") !== null\n      );\n    } catch (e) {\n      throw new Error(\n        `[${redirectUrl}] is not a valid URL, and cannot be used as a redirect URL: ${e.toString()}`\n      );\n    }\n  }\n\n  async handle(\n    redirectUrl: string,\n    eventEmitter?: EventEmitter\n  ): Promise<ISessionInfo & { fetch: typeof fetch }> {\n    if (!(await this.canHandle(redirectUrl))) {\n      throw new Error(\n        `AuthCodeRedirectHandler cannot handle [${redirectUrl}]: it is missing one of [code, state].`\n      );\n    }\n\n    const url = new URL(redirectUrl);\n    const oauthState = url.searchParams.get(\"state\") as string;\n\n    const storedSessionId = (await this.storageUtility.getForUser(\n      oauthState,\n      \"sessionId\",\n      {\n        errorIfNull: true,\n      }\n    )) as string;\n    const isDpop =\n      (await this.storageUtility.getForUser(storedSessionId, \"dpop\")) ===\n      \"true\";\n\n    // Since we throw if not found, the type assertion is okay\n    const issuer = (await this.storageUtility.getForUser(\n      storedSessionId,\n      \"issuer\",\n      { errorIfNull: true }\n    )) as string;\n\n    // Store the current session ID specifically in 'localStorage' (i.e., not using\n    // any other storage mechanism), as we don't deem this information to be\n    // sensitive, and we want to ensure it survives a browser tab refresh.\n    window.localStorage.setItem(KEY_CURRENT_SESSION, storedSessionId);\n\n    const issuerConfig = await this.issuerConfigFetcher.fetchConfig(issuer);\n    const client: IClient = await this.clientRegistrar.getClient(\n      { sessionId: storedSessionId },\n      issuerConfig\n    );\n\n    let tokens: CodeExchangeResult;\n    const referenceTime = Date.now();\n\n    if (isDpop) {\n      const codeVerifier = (await this.storageUtility.getForUser(\n        storedSessionId,\n        \"codeVerifier\",\n        { errorIfNull: true }\n      )) as string;\n\n      const storedRedirectIri = (await this.storageUtility.getForUser(\n        storedSessionId,\n        \"redirectUrl\",\n        { errorIfNull: true }\n      )) as string;\n\n      tokens = await getDpopToken(issuerConfig, client, {\n        grantType: \"authorization_code\",\n        // We rely on our 'canHandle' function checking that the OAuth 'code'\n        // parameter is present in our query string.\n        code: url.searchParams.get(\"code\") as string,\n        codeVerifier,\n        redirectUrl: storedRedirectIri,\n      });\n    } else {\n      tokens = await getBearerToken(url.toString());\n    }\n\n    let refreshOptions: RefreshOptions | undefined;\n    if (tokens.refreshToken !== undefined) {\n      refreshOptions = {\n        sessionId: storedSessionId,\n        refreshToken: tokens.refreshToken,\n        tokenRefresher: this.tokerRefresher,\n      };\n    }\n\n    const authFetch = await buildAuthenticatedFetch(fetch, tokens.accessToken, {\n      dpopKey: tokens.dpopKey,\n      refreshOptions,\n      eventEmitter,\n      expiresIn: tokens.expiresIn,\n    });\n\n    await this.storageUtility.setForUser(\n      storedSessionId,\n      {\n        // TODO: We need a PR to oidc-client-js to add parsing of the\n        //  refresh_token from the redirect URL.\n        refreshToken:\n          \"<Refresh token that *is* coming back in the redirect URL is not yet being parsed and provided by oidc-client-js in it's response object>\",\n        webId: tokens.webId,\n        isLoggedIn: \"true\",\n      },\n      { secure: true }\n    );\n    // Clear the code query param from the redirect URL before storing it, but\n    // preserve any state that my have been provided by the client and returned\n    // by the IdP.\n    url.searchParams.delete(\"code\");\n    await this.storageUtility.setForUser(\n      storedSessionId,\n      {\n        redirectUrl: url.toString(),\n        idToken: tokens.idToken,\n      },\n      {\n        secure: false,\n      }\n    );\n    // TODO: This is a temporary workaround. When deprecating the cookie-based auth,\n    // this should be all cleared.\n    const essWorkaroundDisabled =\n      window.localStorage.getItem(\"tmp-resource-server-session-enabled\") ===\n      \"false\";\n    if (!essWorkaroundDisabled) {\n      await setupResourceServerSession(\n        tokens.webId,\n        authFetch,\n        this.storageUtility\n      );\n    }\n\n    const sessionInfo = await this.sessionInfoManager.get(storedSessionId);\n    if (!sessionInfo) {\n      throw new Error(`Could not retrieve session: [${storedSessionId}].`);\n    }\n\n    return Object.assign(sessionInfo, {\n      fetch: authFetch,\n      expirationDate:\n        typeof tokens.expiresIn === \"number\"\n          ? referenceTime + tokens.expiresIn * 1000\n          : null,\n    });\n  }\n}\n"]}},"error":null,"hash":"8a062344f9674d1c22b88379c7f81366","cacheData":{"env":{}}}