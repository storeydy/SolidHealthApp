{"id":"node_modules/@inrupt/solid-client-authn-core/dist/errors/InruptError.js","dependencies":[{"name":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\storeydy.github.io\\node_modules\\@inrupt\\solid-client-authn-core\\dist\\errors\\InruptError.js.map","includedInParent":true,"mtime":1645788390990},{"name":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\storeydy.github.io\\node_modules\\@inrupt\\solid-client-authn-core\\src\\errors\\InruptError.ts","includedInParent":true,"mtime":1645788391039},{"name":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\storeydy.github.io\\package.json","includedInParent":true,"mtime":1645793376876},{"name":"C:\\Users\\store\\Documents\\College\\5th Year\\MAI Project\\storeydy.github.io\\node_modules\\@inrupt\\solid-client-authn-core\\package.json","includedInParent":true,"mtime":1645788391034}],"generated":{"js":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nclass InruptError extends Error {\r\n    constructor(messageOrIri, messageParams, appendErrorIri = true) {\r\n        super(typeof messageOrIri === \"string\"\r\n            ? InruptError.substituteParams(messageOrIri, messageParams)\r\n            : InruptError.appendErrorIri(InruptError.lookupErrorIri(messageOrIri, messageParams), messageOrIri, appendErrorIri));\r\n    }\r\n    httpResponse(httpErrorResponse, appendHttpDetails = true) {\r\n        this.message = InruptError.appendHttpResponseDetails(this.message, httpErrorResponse, appendHttpDetails);\r\n        this.httpErrorResponse = httpErrorResponse;\r\n        return this;\r\n    }\r\n    hasHttpResponse() {\r\n        return this.httpErrorResponse !== undefined;\r\n    }\r\n    getHttpResponse() {\r\n        return this.httpErrorResponse;\r\n    }\r\n    getHttpStatusCode() {\r\n        if (this.httpErrorResponse === undefined) {\r\n            throw new InruptError(\"This InruptError was not provided with a HTTP response - so we can't get its HTTP Status Code.\");\r\n        }\r\n        return this.httpErrorResponse.status;\r\n    }\r\n    getHttpStatusText() {\r\n        if (this.httpErrorResponse === undefined) {\r\n            throw new InruptError(\"This InruptError was not provided with a HTTP response - so we can't get its HTTP Status Text!\");\r\n        }\r\n        return this.httpErrorResponse.statusText;\r\n    }\r\n    static determineIfVocabTerm(value) {\r\n        if (value.strict !== undefined) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    static lookupErrorIri(iri, messageParams) {\r\n        if (InruptError.determineIfVocabTerm(iri)) {\r\n            const message = messageParams === undefined\r\n                ? iri.message\r\n                : iri.messageParams(...messageParams);\r\n            return message === undefined\r\n                ? `Looked up error message IRI [${iri.value}], but found no message value.`\r\n                : message;\r\n        }\r\n        return `Error message looked up at: [${iri.value}]${messageParams === undefined\r\n            ? \"\"\r\n            : `, with params [${messageParams.toString()}]`}`;\r\n    }\r\n    static appendHttpResponseDetails(message, response, append) {\r\n        if (append && typeof response !== \"undefined\") {\r\n            return `${message} HTTP details: status code [${response.status}], status text [${response.statusText}].`;\r\n        }\r\n        return message;\r\n    }\r\n    static appendErrorIri(message, iri, append) {\r\n        return append ? `${message} Error IRI: [${iri.value}].` : message;\r\n    }\r\n    static substituteParams(message, params) {\r\n        let fullMessage = message;\r\n        if (params !== undefined) {\r\n            const paramsRequired = message.split(\"{{\").length - 1;\r\n            if (paramsRequired !== params.length) {\r\n                throw new Error(`Setting parameters on message [${message}], but it requires [${paramsRequired}] params and we received [${params.length}].`);\r\n            }\r\n            for (let i = 0; i < params.length; i += 1) {\r\n                const marker = `{{${i}}}`;\r\n                fullMessage = fullMessage.replace(marker, params[i]);\r\n            }\r\n        }\r\n        return fullMessage;\r\n    }\r\n}\r\nexports.default = InruptError;\r\n"},"sourceMaps":{"js":{"version":3,"file":"InruptError.js","sourceRoot":"","sources":["../../src/errors/InruptError.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n * Copyright 2021 Inrupt Inc.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal in\r\n * the Software without restriction, including without limitation the rights to use,\r\n * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\r\n * Software, and to permit persons to whom the Software is furnished to do so,\r\n * subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\r\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\r\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\r\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\n/**\r\n * @hidden\r\n * The generic Inrupt error class, that simply extends the regular JavaScript\r\n * [[Error]] object but provides extra capabilities and meta-data (e.g.\r\n * potentially data from a HTTP response, or with data from an RDF vocabulary\r\n * (which may be imported locally, or looked up dynamically at runtime)).\r\n *\r\n * Error Identifiers\r\n *   Our error class supports the notion of globally unique, dereferenceable\r\n *   error identifiers in the form of IRIs.\r\n *\r\n * Parameterized error messages\r\n *   This class supports error messages with positional placeholders that can be\r\n *   replaced by developer-provided parameter values at runtime.\r\n *\r\n * Wrapped Errors (Coming soon!)\r\n *   Similar to how Java supports the notion of wrapped exceptions, our error\r\n *   class implementation supports the ability to wrap [[Error]]s.\r\n *\r\n * HTTP errors:\r\n *   This class provides a very convenient means to provide a HTTP response,\r\n *   the details from which can be appended to error message strings, and the\r\n *   response itself retrieved directly by consumers of instances of this class.\r\n * @packageDocumentation\r\n */\r\n\r\nimport { VocabTerm, NamedNode } from \"@inrupt/solid-common-vocab\";\r\n\r\nexport default class InruptError extends Error {\r\n  // For the common case of HTTP errors, we can store the HTTP response to allow\r\n  // consumers of this error instance to access it directly.\r\n  // NOTE: we specifically stipulate that we expect the HTTP response to be an\r\n  // error response!\r\n  private httpErrorResponse?: Response & { ok: false };\r\n\r\n  constructor(\r\n    messageOrIri: string | NamedNode | VocabTerm,\r\n    messageParams?: string[],\r\n    appendErrorIri = true\r\n  ) {\r\n    super(\r\n      typeof messageOrIri === \"string\"\r\n        ? InruptError.substituteParams(messageOrIri, messageParams)\r\n        : InruptError.appendErrorIri(\r\n            InruptError.lookupErrorIri(messageOrIri, messageParams),\r\n            messageOrIri as NamedNode,\r\n            appendErrorIri\r\n          )\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Allows us provide a HTTP response, and to specify if we want details from\r\n   * that response to be appended to our error message string. We also preserve\r\n   * specific state from that response object to allow consumers of this error\r\n   * to directly access those if they wish.\r\n   *\r\n   * @param httpErrorResponse\r\n   * @param appendHttpDetails\r\n   */\r\n  public httpResponse(\r\n    httpErrorResponse: Response & { ok: false },\r\n    appendHttpDetails = true\r\n  ): InruptError {\r\n    this.message = InruptError.appendHttpResponseDetails(\r\n      this.message,\r\n      httpErrorResponse,\r\n      appendHttpDetails\r\n    );\r\n\r\n    // Preserve the HTTP response (in case the consumer of this error wishes to\r\n    // access its details directly themselves).\r\n    this.httpErrorResponse = httpErrorResponse;\r\n\r\n    return this;\r\n  }\r\n\r\n  hasHttpResponse(): boolean {\r\n    return this.httpErrorResponse !== undefined;\r\n  }\r\n\r\n  getHttpResponse(): (Response & { ok: false }) | undefined {\r\n    return this.httpErrorResponse;\r\n  }\r\n\r\n  getHttpStatusCode(): number {\r\n    if (this.httpErrorResponse === undefined) {\r\n      throw new InruptError(\r\n        \"This InruptError was not provided with a HTTP response - so we can't get its HTTP Status Code.\"\r\n      );\r\n    }\r\n\r\n    return this.httpErrorResponse.status;\r\n  }\r\n\r\n  getHttpStatusText(): string {\r\n    if (this.httpErrorResponse === undefined) {\r\n      throw new InruptError(\r\n        \"This InruptError was not provided with a HTTP response - so we can't get its HTTP Status Text!\"\r\n      );\r\n    }\r\n\r\n    return this.httpErrorResponse.statusText;\r\n  }\r\n\r\n  static determineIfVocabTerm(\r\n    value: NamedNode | VocabTerm\r\n  ): value is VocabTerm {\r\n    if ((value as VocabTerm).strict !== undefined) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Given the IRI for an error message term, first check if it's a local\r\n   * Vocab Term (in which case we expect the error messages (in potentially\r\n   * multiple languages) to be accessible directly.\r\n   * If however the IRI is just a raw IRI, then attempt to lookup the term\r\n   * dynamically by simply de-referencing it and asking for RDF back (which we\r\n   * then need to parse and extract the relevant message string).\r\n   *\r\n   * NOTE: if we find the referenced term, but it has no explicit message\r\n   * values associated with it (e.g. the term `https://schema.org/Person` would\r\n   * resolve, but it has no Vocab Term-defined 'message' triples associated with\r\n   * it), then we return a fixed message string explaining this, but that\r\n   * includes the error IRI and the provided parameters.\r\n   *\r\n   * @param iri the IRI of the error message term from an RDF vocabulary\r\n   * @param messageParams parameters to replace expected placeholders in the message string\r\n   */\r\n  static lookupErrorIri(\r\n    iri: NamedNode | VocabTerm,\r\n    messageParams?: string[]\r\n  ): string {\r\n    if (InruptError.determineIfVocabTerm(iri)) {\r\n      const message =\r\n        messageParams === undefined\r\n          ? iri.message\r\n          : iri.messageParams(...messageParams);\r\n\r\n      return message === undefined\r\n        ? `Looked up error message IRI [${iri.value}], but found no message value.`\r\n        : message;\r\n    }\r\n\r\n    return `Error message looked up at: [${iri.value}]${\r\n      messageParams === undefined\r\n        ? \"\"\r\n        : `, with params [${messageParams.toString()}]`\r\n    }`;\r\n  }\r\n\r\n  /**\r\n   * Convenience method to append certain HTTP response details to our error\r\n   * message (e.g. the HTTP status code, or the status text).\r\n   *\r\n   * @param message the message string to append to\r\n   * @param response the optional HTTP response\r\n   * @param append flag telling us to append or not\r\n   */\r\n  static appendHttpResponseDetails(\r\n    message: string,\r\n    response: Response | undefined,\r\n    append: boolean\r\n  ): string {\r\n    if (append && typeof response !== \"undefined\") {\r\n      return `${message} HTTP details: status code [${response.status}], status text [${response.statusText}].`;\r\n    }\r\n\r\n    return message;\r\n  }\r\n\r\n  /**\r\n   * Convenience method to append the error term's IRI value to our error\r\n   * message (which can be a very helpful reference, since it's basically the ID\r\n   * of the error message itself).\r\n   *\r\n   * @param message the message string to append to\r\n   * @param iri the IRI of the error term\r\n   * @param append flag telling us to append or not\r\n   */\r\n  static appendErrorIri(\r\n    message: string,\r\n    iri: NamedNode,\r\n    append: boolean\r\n  ): string {\r\n    return append ? `${message} Error IRI: [${iri.value}].` : message;\r\n  }\r\n\r\n  /**\r\n   * Scans the specified message returning a copy with all placeholders replaced\r\n   * with their corresponding parameter value.\r\n   *\r\n   * Note: If the number of parameters provided does not exactly match the\r\n   * number of placeholders, we throw an exception explaining this (as we\r\n   * consider it a programmer error).\r\n   *\r\n   * @param message the message within which to replace placeholders\r\n   * @param params the parameters to replaces the placeholders\r\n   */\r\n  static substituteParams(message: string, params?: string[]): string {\r\n    let fullMessage = message;\r\n    if (params !== undefined) {\r\n      const paramsRequired = message.split(\"{{\").length - 1;\r\n      if (paramsRequired !== params.length) {\r\n        throw new Error(\r\n          `Setting parameters on message [${message}], but it requires [${paramsRequired}] params and we received [${params.length}].`\r\n        );\r\n      }\r\n\r\n      for (let i = 0; i < params.length; i += 1) {\r\n        const marker = `{{${i}}}`;\r\n        fullMessage = fullMessage.replace(marker, params[i]);\r\n      }\r\n    }\r\n\r\n    return fullMessage;\r\n  }\r\n}\r\n"]}},"error":null,"hash":"5d02b41ae262b514fe86025698d07f0e","cacheData":{"env":{}}}