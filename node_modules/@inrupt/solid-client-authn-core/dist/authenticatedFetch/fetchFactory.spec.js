"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const globals_1 = require("@jest/globals");
const jose_legacy_modules_1 = require("@inrupt/jose-legacy-modules");
const events_1 = require("events");
const fetchFactory_1 = require("./fetchFactory");
const TokenRefresher_1 = require("../login/oidc/refresh/__mocks__/TokenRefresher");
const constant_1 = require("../constant");
const OidcProviderError_1 = require("../errors/OidcProviderError");
const InvalidResponseError_1 = require("../errors/InvalidResponseError");
globals_1.jest.mock("cross-fetch");
const mockNotRedirectedResponse = () => {
    return {
        redirected: false,
        url: "http://some.url",
    };
};
let publicKey;
let privateKey;
const mockJwk = async () => {
    if (typeof publicKey === "undefined" || typeof privateKey === "undefined") {
        const generatedPair = await jose_legacy_modules_1.generateKeyPair("ES256");
        publicKey = generatedPair.publicKey;
        privateKey = generatedPair.privateKey;
    }
    return {
        publicKey,
        privateKey,
    };
};
const mockKeyPair = async () => {
    const { privateKey: prvt, publicKey: pblc } = await mockJwk();
    const dpopKeyPair = {
        privateKey: prvt,
        publicKey: await jose_legacy_modules_1.fromKeyLike(pblc),
    };
    dpopKeyPair.publicKey.alg = "ES256";
    return dpopKeyPair;
};
globals_1.describe("buildAuthenticatedFetch", () => {
    globals_1.it("builds a DPoP fetch if a DPoP key is provided", async () => {
        const fetch = globals_1.jest.requireMock("cross-fetch");
        fetch.mockResolvedValue({
            status: 401,
            url: "https://my.pod/resource",
        });
        const keylikePair = await mockJwk();
        const myFetch = await fetchFactory_1.buildAuthenticatedFetch(fetch, "myToken", {
            dpopKey: {
                privateKey: keylikePair.privateKey,
                publicKey: await jose_legacy_modules_1.fromKeyLike(keylikePair.publicKey),
            },
            refreshOptions: {
                refreshToken: "some refresh token",
                sessionId: "mySession",
                tokenRefresher: {
                    refresh: globals_1.jest.fn(),
                },
            },
        });
        await myFetch("https://my.pod/resource");
        globals_1.expect(fetch.mock.calls[0][0]).toEqual("https://my.pod/resource");
        const dpopHeader = fetch.mock.calls[0][1].headers.DPoP;
        const decodedHeader = await jose_legacy_modules_1.jwtVerify(dpopHeader, (await mockJwk()).publicKey);
        globals_1.expect(decodedHeader.payload).toMatchObject({
            htu: "https://my.pod/resource",
        });
    });
    globals_1.it("builds the appropriate DPoP header for a given HTTP verb.", async () => {
        const mockedFetch = globals_1.jest.requireMock("cross-fetch");
        mockedFetch.mockResolvedValueOnce(mockNotRedirectedResponse());
        const myFetch = await fetchFactory_1.buildAuthenticatedFetch(mockedFetch, "myToken", {
            dpopKey: await mockKeyPair(),
        });
        await myFetch("http://some.url", {
            method: "POST",
        });
        const dpopHeader = mockedFetch.mock.calls[0][1].headers.DPoP;
        const { payload } = await jose_legacy_modules_1.jwtVerify(dpopHeader, (await mockKeyPair()).privateKey);
        globals_1.expect(payload.htu).toEqual("http://some.url/");
        globals_1.expect(payload.htm).toEqual("POST");
    });
    globals_1.it("builds a Bearer fetch if no DPoP key is provided", async () => {
        const fetch = globals_1.jest.requireMock("cross-fetch");
        fetch.mockResolvedValue({
            status: 401,
            url: "https://my.pod/resource",
        });
        const myFetch = await fetchFactory_1.buildAuthenticatedFetch(fetch, "myToken", undefined);
        await myFetch("https://my.pod/resource");
        globals_1.expect(fetch.mock.calls[0][0]).toEqual("https://my.pod/resource");
        const authorizationHeader = fetch.mock.calls[0][1].headers
            .Authorization;
        globals_1.expect(authorizationHeader.startsWith("Bearer")).toBe(true);
    });
    globals_1.it("returns a fetch that rebuilds the DPoP token if redirected", async () => {
        const mockedFetch = globals_1.jest.requireMock("cross-fetch");
        mockedFetch
            .mockResolvedValueOnce({
            url: "https://my.pod/container/",
            status: 403,
            ok: false,
        })
            .mockResolvedValueOnce({
            url: "https://my.pod/container/",
            ok: true,
            status: 200,
        });
        const myFetch = await fetchFactory_1.buildAuthenticatedFetch(mockedFetch, "myToken", {
            dpopKey: await mockKeyPair(),
        });
        await myFetch("https://my.pod/container");
        globals_1.expect(mockedFetch.mock.calls[1][0]).toEqual("https://my.pod/container/");
        const dpopHeader = mockedFetch.mock.calls[1][1].headers.DPoP;
        const { payload } = await jose_legacy_modules_1.jwtVerify(dpopHeader, (await mockKeyPair()).privateKey);
        globals_1.expect(payload.htu).toEqual("https://my.pod/container/");
    });
    globals_1.it("returns a fetch that does not retry fetching with a Bearer token if redirected", async () => {
        const mockedFetch = globals_1.jest.requireMock("cross-fetch");
        mockedFetch.mockResolvedValueOnce({
            url: "https://my.pod/container/",
            status: 403,
            ok: false,
        });
        const myFetch = await fetchFactory_1.buildAuthenticatedFetch(mockedFetch, "myToken");
        const response = await myFetch("https://my.pod/container");
        globals_1.expect(response.status).toBe(403);
        globals_1.expect(mockedFetch.mock.calls).toHaveLength(1);
    });
    globals_1.it("returns a fetch preserving the optional headers", async () => {
        const fetch = globals_1.jest.requireMock("cross-fetch");
        fetch.mockResolvedValueOnce(mockNotRedirectedResponse());
        const myFetch = await fetchFactory_1.buildAuthenticatedFetch(fetch, "myToken", undefined);
        await myFetch("someUrl", { headers: { someHeader: "SomeValue" } });
        globals_1.expect(fetch.mock.calls[0][1].headers.Authorization).toEqual("Bearer myToken");
        globals_1.expect(fetch.mock.calls[0][1].headers.someHeader).toEqual("SomeValue");
    });
    globals_1.it("returns a fetch overriding any pre-existing Authorization or DPoP headers", async () => {
        const mockedFetch = globals_1.jest.requireMock("cross-fetch");
        mockedFetch.mockResolvedValueOnce(mockNotRedirectedResponse());
        const myFetch = await fetchFactory_1.buildAuthenticatedFetch(mockedFetch, "myToken", {
            dpopKey: await mockKeyPair(),
        });
        await myFetch("http://some.url", {
            headers: {
                Authorization: "some token",
                DPoP: "some header",
            },
        });
        globals_1.expect(mockedFetch.mock.calls[0][1].headers.Authorization).toEqual("DPoP myToken");
    });
    globals_1.it("does not retry a **redirected** fetch if the error is not auth-related", async () => {
        const mockedFetch = globals_1.jest.requireMock("cross-fetch");
        mockedFetch.mockResolvedValueOnce({
            url: "https://my.pod/container/",
            status: 400,
            ok: false,
        });
        const myFetch = await fetchFactory_1.buildAuthenticatedFetch(mockedFetch, "myToken", {
            dpopKey: await mockKeyPair(),
        });
        const response = await myFetch("https://my.pod/container");
        globals_1.expect(mockedFetch.mock.calls).toHaveLength(1);
        globals_1.expect(response.status).toEqual(400);
    });
    globals_1.it("returns the initial response in case of non-redirected auth error", async () => {
        const fetch = globals_1.jest.requireMock("cross-fetch");
        fetch.mockResolvedValueOnce({ status: 401 });
        const myFetch = await fetchFactory_1.buildAuthenticatedFetch(fetch, "myToken", {
            refreshOptions: {
                refreshToken: "some refresh token",
                sessionId: "mySession",
                tokenRefresher: {
                    refresh: () => {
                        throw new Error("Some error");
                    },
                },
            },
        });
        const response = await myFetch("someUrl");
        globals_1.expect(response.status).toEqual(401);
    });
    function sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
    }
    globals_1.it("refreshes the token before it expires", async () => {
        const mockedFetch = globals_1.jest.requireMock("cross-fetch");
        const mockRefresher = TokenRefresher_1.mockDefaultTokenRefresher();
        await fetchFactory_1.buildAuthenticatedFetch(mockedFetch, "myToken", {
            refreshOptions: {
                refreshToken: "some refresh token",
                sessionId: "mySession",
                tokenRefresher: mockRefresher,
            },
            expiresIn: 6,
        });
        globals_1.expect(mockRefresher.refresh).not.toHaveBeenCalled();
        await sleep(500);
        globals_1.expect(mockRefresher.refresh).not.toHaveBeenCalled();
        await sleep(500);
        globals_1.expect(mockRefresher.refresh).toHaveBeenCalled();
    });
    globals_1.it("sets a default timeout if the OIDC provider did not return one", async () => {
        const mockedFetch = globals_1.jest.requireMock("cross-fetch");
        const mockRefresher = TokenRefresher_1.mockDefaultTokenRefresher();
        const spyTimeout = globals_1.jest.spyOn(global, "setTimeout");
        await fetchFactory_1.buildAuthenticatedFetch(mockedFetch, "myToken", {
            refreshOptions: {
                refreshToken: "some refresh token",
                sessionId: "mySession",
                tokenRefresher: mockRefresher,
            },
        });
        globals_1.expect(spyTimeout).toHaveBeenLastCalledWith(globals_1.expect.any(Function), fetchFactory_1.DEFAULT_EXPIRATION_TIME_SECONDS * 1000);
    });
    globals_1.it("does not rebind the DPoP token on refresh", async () => {
        const mockedFetch = globals_1.jest.requireMock("cross-fetch");
        const keylikePair = await mockJwk();
        const mockedTokenRefresher = {
            refresh: globals_1.jest
                .fn()
                .mockResolvedValueOnce({
                ...TokenRefresher_1.mockDefaultTokenSet(),
                refreshToken: "some rotated refresh token",
                expiresIn: 0,
            })
                .mockResolvedValue({ ...TokenRefresher_1.mockDefaultTokenSet(), expiresIn: 1000 }),
        };
        await fetchFactory_1.buildAuthenticatedFetch(mockedFetch, "myToken", {
            dpopKey: {
                privateKey: keylikePair.privateKey,
                publicKey: await jose_legacy_modules_1.fromKeyLike(keylikePair.publicKey),
            },
            refreshOptions: {
                refreshToken: "some refresh token",
                sessionId: "mySession",
                tokenRefresher: mockedTokenRefresher,
            },
            expiresIn: 0,
        });
        await sleep(200);
        globals_1.expect(mockedTokenRefresher.refresh).toHaveBeenCalledWith(globals_1.expect.anything(), "some refresh token", {
            privateKey: keylikePair.privateKey,
            publicKey: await jose_legacy_modules_1.fromKeyLike(keylikePair.publicKey),
        });
    });
    globals_1.it("sets up the timeout on refresh so that the tokens keep being valid", async () => {
        const mockedFetch = globals_1.jest.requireMock("cross-fetch");
        const mockRefresher = TokenRefresher_1.mockTokenRefresher({
            ...TokenRefresher_1.mockDefaultTokenSet(),
            expiresIn: 7,
        });
        const spyTimeout = globals_1.jest.spyOn(global, "setTimeout");
        const mockedEmitter = new events_1.EventEmitter();
        const spiedEmit = globals_1.jest.spyOn(mockedEmitter, "emit");
        await fetchFactory_1.buildAuthenticatedFetch(mockedFetch, "myToken", {
            refreshOptions: {
                refreshToken: "some refresh token",
                sessionId: "mySession",
                tokenRefresher: mockRefresher,
            },
            expiresIn: 6,
            eventEmitter: mockedEmitter,
        });
        await sleep(1000);
        globals_1.expect(mockRefresher.refresh).toHaveBeenCalled();
        globals_1.expect(spyTimeout).toHaveBeenLastCalledWith(globals_1.expect.any(Function), 2 * 1000);
        globals_1.expect(spiedEmit).toHaveBeenCalledWith(constant_1.EVENTS.TIMEOUT_SET, globals_1.expect.anything());
    });
    globals_1.it("sets a default timeout on refresh if the OIDC provider does not return one", async () => {
        const mockedFetch = globals_1.jest.requireMock("cross-fetch");
        const mockRefresher = TokenRefresher_1.mockTokenRefresher({
            ...TokenRefresher_1.mockDefaultTokenSet(),
            expiresIn: undefined,
        });
        const spyTimeout = globals_1.jest.spyOn(global, "setTimeout");
        await fetchFactory_1.buildAuthenticatedFetch(mockedFetch, "myToken", {
            refreshOptions: {
                refreshToken: "some refresh token",
                sessionId: "mySession",
                tokenRefresher: mockRefresher,
            },
            expiresIn: 6,
        });
        await sleep(1000);
        globals_1.expect(mockRefresher.refresh).toHaveBeenCalled();
        globals_1.expect(spyTimeout).toHaveBeenLastCalledWith(globals_1.expect.any(Function), fetchFactory_1.DEFAULT_EXPIRATION_TIME_SECONDS * 1000);
    });
    globals_1.it("calls the provided callback when the access token is refreshed", async () => {
        const mockedFetch = globals_1.jest.requireMock("cross-fetch");
        const tokenSet = TokenRefresher_1.mockDefaultTokenSet();
        const mockedFreshener = TokenRefresher_1.mockTokenRefresher({
            ...tokenSet,
            expiresIn: 1800,
        });
        const eventEmitter = new events_1.EventEmitter();
        const spiedEmit = globals_1.jest.spyOn(eventEmitter, "emit");
        await fetchFactory_1.buildAuthenticatedFetch(mockedFetch, "myToken", {
            refreshOptions: {
                refreshToken: "some refresh token",
                sessionId: "mySession",
                tokenRefresher: mockedFreshener,
            },
            eventEmitter,
            expiresIn: 0,
        });
        await sleep(200);
        globals_1.expect(spiedEmit).toHaveBeenCalledWith(constant_1.EVENTS.SESSION_EXTENDED, 1800);
    });
    globals_1.it("calls the provided callback when a new refresh token is issued", async () => {
        const mockedFetch = globals_1.jest.requireMock("cross-fetch");
        const tokenSet = TokenRefresher_1.mockDefaultTokenSet();
        tokenSet.refreshToken = "some rotated refresh token";
        const mockedFreshener = TokenRefresher_1.mockTokenRefresher(tokenSet);
        const eventEmitter = new events_1.EventEmitter();
        const spiedEmit = globals_1.jest.spyOn(eventEmitter, "emit");
        await fetchFactory_1.buildAuthenticatedFetch(mockedFetch, "myToken", {
            refreshOptions: {
                refreshToken: "some refresh token",
                sessionId: "mySession",
                tokenRefresher: mockedFreshener,
            },
            eventEmitter,
            expiresIn: 0,
        });
        await sleep(200);
        globals_1.expect(spiedEmit).toHaveBeenCalledWith(constant_1.EVENTS.NEW_REFRESH_TOKEN, "some rotated refresh token");
    });
    globals_1.it("rotates the refresh token if a new one is issued", async () => {
        const mockedFetch = globals_1.jest.requireMock("cross-fetch");
        const mockedTokenRefresher = {
            refresh: globals_1.jest
                .fn()
                .mockResolvedValueOnce({
                ...TokenRefresher_1.mockDefaultTokenSet(),
                refreshToken: "some rotated refresh token",
                expiresIn: 0,
            })
                .mockResolvedValue({ ...TokenRefresher_1.mockDefaultTokenSet(), expiresIn: 1000 }),
        };
        const refreshCall = globals_1.jest.spyOn(mockedTokenRefresher, "refresh");
        await fetchFactory_1.buildAuthenticatedFetch(mockedFetch, "myToken", {
            refreshOptions: {
                refreshToken: "some refresh token",
                sessionId: "mySession",
                tokenRefresher: mockedTokenRefresher,
            },
            expiresIn: 0,
        });
        await sleep(200);
        globals_1.expect(refreshCall.mock.calls[1][1]).toEqual("some rotated refresh token");
    });
    globals_1.it("emits the appropriate events when refreshing the token fails", async () => {
        const mockedFetch = globals_1.jest.requireMock("cross-fetch");
        const mockedFreshener = TokenRefresher_1.mockTokenRefresher(TokenRefresher_1.mockDefaultTokenSet());
        mockedFreshener.refresh = globals_1.jest
            .fn()
            .mockRejectedValueOnce(new OidcProviderError_1.OidcProviderError("Some error message", "error_identifier", "Some error description"));
        const mockEmitter = new events_1.EventEmitter();
        const spiedEmit = globals_1.jest.spyOn(mockEmitter, "emit");
        await fetchFactory_1.buildAuthenticatedFetch(mockedFetch, "myToken", {
            refreshOptions: {
                refreshToken: "some refresh token",
                sessionId: "mySession",
                tokenRefresher: mockedFreshener,
            },
            expiresIn: 0,
            eventEmitter: mockEmitter,
        });
        await sleep(200);
        globals_1.expect(spiedEmit).toHaveBeenCalledTimes(3);
        globals_1.expect(spiedEmit).toHaveBeenCalledWith(constant_1.EVENTS.TIMEOUT_SET, globals_1.expect.anything());
        globals_1.expect(spiedEmit).toHaveBeenCalledWith(constant_1.EVENTS.SESSION_EXPIRED);
        globals_1.expect(spiedEmit).toHaveBeenCalledWith(constant_1.EVENTS.ERROR, "error_identifier", "Some error description");
    });
    globals_1.it("emits the appropriate events when an unexpected response is received", async () => {
        const mockedFetch = globals_1.jest.requireMock("cross-fetch");
        const mockedFreshener = TokenRefresher_1.mockTokenRefresher(TokenRefresher_1.mockDefaultTokenSet());
        mockedFreshener.refresh = globals_1.jest
            .fn()
            .mockRejectedValueOnce(new InvalidResponseError_1.InvalidResponseError(["access_token"]));
        const mockEmitter = new events_1.EventEmitter();
        const spiedEmit = globals_1.jest.spyOn(mockEmitter, "emit");
        await fetchFactory_1.buildAuthenticatedFetch(mockedFetch, "myToken", {
            refreshOptions: {
                refreshToken: "some refresh token",
                sessionId: "mySession",
                tokenRefresher: mockedFreshener,
            },
            expiresIn: 0,
            eventEmitter: mockEmitter,
        });
        await sleep(100);
        globals_1.expect(spiedEmit).toHaveBeenCalledTimes(2);
        globals_1.expect(spiedEmit).toHaveBeenCalledWith(constant_1.EVENTS.TIMEOUT_SET, globals_1.expect.anything());
        globals_1.expect(spiedEmit).toHaveBeenCalledWith(constant_1.EVENTS.SESSION_EXPIRED);
    });
    globals_1.it("emits the appropriate events when the access token expires and may not be refreshed", async () => {
        const mockedFetch = globals_1.jest.requireMock("cross-fetch");
        const mockedFreshener = TokenRefresher_1.mockTokenRefresher(TokenRefresher_1.mockDefaultTokenSet());
        mockedFreshener.refresh = globals_1.jest
            .fn()
            .mockRejectedValueOnce(new InvalidResponseError_1.InvalidResponseError(["access_token"]));
        const mockEmitter = new events_1.EventEmitter();
        const spiedEmit = globals_1.jest.spyOn(mockEmitter, "emit");
        await fetchFactory_1.buildAuthenticatedFetch(mockedFetch, "myToken", {
            expiresIn: 0,
            eventEmitter: mockEmitter,
        });
        await sleep(100);
        globals_1.expect(spiedEmit).toHaveBeenCalledTimes(2);
        globals_1.expect(spiedEmit).toHaveBeenCalledWith(constant_1.EVENTS.TIMEOUT_SET, globals_1.expect.anything());
        globals_1.expect(spiedEmit).toHaveBeenCalledWith(constant_1.EVENTS.SESSION_EXPIRED);
    });
    globals_1.it("does not schedule any callback to be called if no event can be fired", async () => {
        const mockedFetch = globals_1.jest.requireMock("cross-fetch");
        const spyTimeout = globals_1.jest.spyOn(global, "setTimeout");
        await fetchFactory_1.buildAuthenticatedFetch(mockedFetch, "myToken");
        await sleep(100);
        globals_1.expect(spyTimeout).toHaveBeenCalledTimes(1);
    });
});
//# sourceMappingURL=fetchFactory.spec.js.map