"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuthCodeRedirectHandler = exports.DEFAULT_LIFESPAN = void 0;
const solid_client_authn_core_1 = require("@inrupt/solid-client-authn-core");
const oidc_client_ext_1 = require("@inrupt/oidc-client-ext");
const constant_1 = require("../../../constant");
exports.DEFAULT_LIFESPAN = 30 * 60 * 1000;
async function setupResourceServerSession(webId, authenticatedFetch, storageUtility) {
    const webIdAsUrl = new URL(webId);
    const resourceServerIri = webIdAsUrl.origin;
    await authenticatedFetch(webId);
    try {
        const resourceServerResponse = await authenticatedFetch(`${resourceServerIri}/session`);
        if (resourceServerResponse.status === 200) {
            await storageUtility.storeResourceServerSessionInfo(webId, resourceServerIri, Date.now() + exports.DEFAULT_LIFESPAN);
            return;
        }
        await storageUtility.clearResourceServerSessionInfo(resourceServerIri);
    }
    catch (_e) {
        await storageUtility.clearResourceServerSessionInfo(resourceServerIri);
    }
}
class AuthCodeRedirectHandler {
    constructor(storageUtility, sessionInfoManager, issuerConfigFetcher, clientRegistrar, tokerRefresher) {
        this.storageUtility = storageUtility;
        this.sessionInfoManager = sessionInfoManager;
        this.issuerConfigFetcher = issuerConfigFetcher;
        this.clientRegistrar = clientRegistrar;
        this.tokerRefresher = tokerRefresher;
    }
    async canHandle(redirectUrl) {
        try {
            const myUrl = new URL(redirectUrl);
            return (myUrl.searchParams.get("code") !== null &&
                myUrl.searchParams.get("state") !== null);
        }
        catch (e) {
            throw new Error(`[${redirectUrl}] is not a valid URL, and cannot be used as a redirect URL: ${e.toString()}`);
        }
    }
    async handle(redirectUrl, eventEmitter) {
        if (!(await this.canHandle(redirectUrl))) {
            throw new Error(`AuthCodeRedirectHandler cannot handle [${redirectUrl}]: it is missing one of [code, state].`);
        }
        const url = new URL(redirectUrl);
        const oauthState = url.searchParams.get("state");
        const storedSessionId = (await this.storageUtility.getForUser(oauthState, "sessionId", {
            errorIfNull: true,
        }));
        const isDpop = (await this.storageUtility.getForUser(storedSessionId, "dpop")) ===
            "true";
        const issuer = (await this.storageUtility.getForUser(storedSessionId, "issuer", { errorIfNull: true }));
        window.localStorage.setItem(constant_1.KEY_CURRENT_SESSION, storedSessionId);
        const issuerConfig = await this.issuerConfigFetcher.fetchConfig(issuer);
        const client = await this.clientRegistrar.getClient({ sessionId: storedSessionId }, issuerConfig);
        let tokens;
        const referenceTime = Date.now();
        if (isDpop) {
            const codeVerifier = (await this.storageUtility.getForUser(storedSessionId, "codeVerifier", { errorIfNull: true }));
            const storedRedirectIri = (await this.storageUtility.getForUser(storedSessionId, "redirectUrl", { errorIfNull: true }));
            tokens = await oidc_client_ext_1.getDpopToken(issuerConfig, client, {
                grantType: "authorization_code",
                code: url.searchParams.get("code"),
                codeVerifier,
                redirectUrl: storedRedirectIri,
            });
        }
        else {
            tokens = await oidc_client_ext_1.getBearerToken(url.toString());
        }
        let refreshOptions;
        if (tokens.refreshToken !== undefined) {
            refreshOptions = {
                sessionId: storedSessionId,
                refreshToken: tokens.refreshToken,
                tokenRefresher: this.tokerRefresher,
            };
        }
        const authFetch = await solid_client_authn_core_1.buildAuthenticatedFetch(fetch, tokens.accessToken, {
            dpopKey: tokens.dpopKey,
            refreshOptions,
            eventEmitter,
            expiresIn: tokens.expiresIn,
        });
        await this.storageUtility.setForUser(storedSessionId, {
            refreshToken: "<Refresh token that *is* coming back in the redirect URL is not yet being parsed and provided by oidc-client-js in it's response object>",
            webId: tokens.webId,
            isLoggedIn: "true",
        }, { secure: true });
        url.searchParams.delete("code");
        await this.storageUtility.setForUser(storedSessionId, {
            redirectUrl: url.toString(),
            idToken: tokens.idToken,
        }, {
            secure: false,
        });
        const essWorkaroundDisabled = window.localStorage.getItem("tmp-resource-server-session-enabled") ===
            "false";
        if (!essWorkaroundDisabled) {
            await setupResourceServerSession(tokens.webId, authFetch, this.storageUtility);
        }
        const sessionInfo = await this.sessionInfoManager.get(storedSessionId);
        if (!sessionInfo) {
            throw new Error(`Could not retrieve session: [${storedSessionId}].`);
        }
        return Object.assign(sessionInfo, {
            fetch: authFetch,
            expirationDate: typeof tokens.expiresIn === "number"
                ? referenceTime + tokens.expiresIn * 1000
                : null,
        });
    }
}
exports.AuthCodeRedirectHandler = AuthCodeRedirectHandler;
//# sourceMappingURL=AuthCodeRedirectHandler.js.map